   1               		.file	"ex3.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	columnOutRowIn
  12               	columnOutRowIn:
  13               	.LFB11:
  14               		.file 1 "ex3.c"
   1:ex3.c         **** /*************************************************************************
   2:ex3.c         **** Title:    Testing output to a HD44780 based LCD display.
   3:ex3.c         **** Author:   Peter Fleury  <pfleury@gmx.ch>  http://tinyurl.com/peterfleury
   4:ex3.c         **** File:     $Id: test_lcd.c,v 1.8 2015/01/31 18:04:08 peter Exp $
   5:ex3.c         **** Software: AVR-GCC 4.x
   6:ex3.c         **** Hardware: HD44780 compatible LCD text display
   7:ex3.c         ****           AVR with external SRAM interface if memory-mapped LCD interface is used
   8:ex3.c         ****           any AVR with 7 free I/O pins if 4-bit IO port mode is used
   9:ex3.c         **** **************************************************************************/
  10:ex3.c         **** #include <stdlib.h>
  11:ex3.c         **** #include <avr/io.h>
  12:ex3.c         **** #include <avr/pgmspace.h>
  13:ex3.c         **** #include <util/delay.h>
  14:ex3.c         **** #include "lcd.h"
  15:ex3.c         **** 
  16:ex3.c         **** #define SIZE 10
  17:ex3.c         **** #define ADDRESS 0
  18:ex3.c         **** 
  19:ex3.c         **** char buffer[SIZE + 1] = "1234567890\0";
  20:ex3.c         **** int key;
  21:ex3.c         **** char input = '2';
  22:ex3.c         **** 
  23:ex3.c         **** void columnOutRowIn()
  24:ex3.c         **** {
  15               		.loc 1 24 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  25:ex3.c         **** 
  26:ex3.c         ****     // DDRB
  27:ex3.c         ****     // DDRB = 0b00000011;
  28:ex3.c         ****     // DDRD = 0b11000000;
  29:ex3.c         **** 
  30:ex3.c         ****     DDRB |= (1 << PINB0) | (1 << PINB1);
  21               		.loc 1 30 0
  22 0000 84B1      		in r24,0x4
  23 0002 8360      		ori r24,lo8(3)
  24 0004 84B9      		out 0x4,r24
  31:ex3.c         ****     DDRB &= ~((1 << PINB2) | (1 << PINB3) | (1 << PINB4) | (1 << PINB5));
  25               		.loc 1 31 0
  26 0006 84B1      		in r24,0x4
  27 0008 837C      		andi r24,lo8(-61)
  28 000a 84B9      		out 0x4,r24
  32:ex3.c         ****     DDRD |= (1 << PIND6) | (1 << PIND7);
  29               		.loc 1 32 0
  30 000c 8AB1      		in r24,0xa
  31 000e 806C      		ori r24,lo8(-64)
  32 0010 8AB9      		out 0xa,r24
  33:ex3.c         **** 
  34:ex3.c         ****     // PORTB = 0b00000011;
  35:ex3.c         ****     // PORTD = 0b11000000;
  36:ex3.c         **** 
  37:ex3.c         ****     PORTB |= (1 << PINB0) | (1 << PINB1);
  33               		.loc 1 37 0
  34 0012 85B1      		in r24,0x5
  35 0014 8360      		ori r24,lo8(3)
  36 0016 85B9      		out 0x5,r24
  38:ex3.c         ****     PORTB &= ~((1 << PINB2) | (1 << PINB3) | (1 << PINB4) | (1 << PINB5));
  37               		.loc 1 38 0
  38 0018 85B1      		in r24,0x5
  39 001a 837C      		andi r24,lo8(-61)
  40 001c 85B9      		out 0x5,r24
  39:ex3.c         ****     PORTD |= (1 << PIND6) | (1 << PIND7);
  41               		.loc 1 39 0
  42 001e 8BB1      		in r24,0xb
  43 0020 806C      		ori r24,lo8(-64)
  44 0022 8BB9      		out 0xb,r24
  45               	.LVL0:
  46               	.LBB23:
  47               	.LBB24:
  48               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  49               		.loc 2 187 0
  50 0024 8FE3      		ldi r24,lo8(-25537)
  51 0026 9CE9      		ldi r25,hi8(-25537)
  52 0028 0197      	1:	sbiw r24,1
  53 002a 01F4      		brne 1b
  54 002c 00C0      		rjmp .
  55 002e 0000      		nop
  56               	.LVL1:
  57 0030 0895      		ret
  58               	.LBE24:
  59               	.LBE23:
  60               		.cfi_endproc
  61               	.LFE11:
  63               	.global	columnInRowOut
  65               	columnInRowOut:
  66               	.LFB12:
  40:ex3.c         **** 
  41:ex3.c         ****     _delay_ms(10);
  42:ex3.c         **** }
  43:ex3.c         **** 
  44:ex3.c         **** void columnInRowOut()
  45:ex3.c         **** {
  67               		.loc 1 45 0
  68               		.cfi_startproc
  69               	/* prologue: function */
  70               	/* frame size = 0 */
  71               	/* stack size = 0 */
  72               	.L__stack_usage = 0
  46:ex3.c         ****     // DDRB = 0b00111100;
  47:ex3.c         ****     // DDRD = 0b00000000;
  48:ex3.c         **** 
  49:ex3.c         ****     DDRB |= (1 << PINB2) | (1 << PINB3) | (1 << PINB4) | (1 << PINB5);
  73               		.loc 1 49 0
  74 0032 84B1      		in r24,0x4
  75 0034 8C63      		ori r24,lo8(60)
  76 0036 84B9      		out 0x4,r24
  50:ex3.c         ****     DDRB &= ~((1 << PINB0) | (1 << PINB1));
  77               		.loc 1 50 0
  78 0038 84B1      		in r24,0x4
  79 003a 8C7F      		andi r24,lo8(-4)
  80 003c 84B9      		out 0x4,r24
  51:ex3.c         ****     DDRD &= ~((1 << PIND6) | (1 << PIND7));
  81               		.loc 1 51 0
  82 003e 8AB1      		in r24,0xa
  83 0040 8F73      		andi r24,lo8(63)
  84 0042 8AB9      		out 0xa,r24
  52:ex3.c         **** 
  53:ex3.c         ****     // PORTB = 0b00111100;
  54:ex3.c         ****     // PORTD = 0b00000000;
  55:ex3.c         **** 
  56:ex3.c         ****     PORTB |= (1 << PINB2) | (1 << PINB3) | (1 << PINB4) | (1 << PINB5);
  85               		.loc 1 56 0
  86 0044 85B1      		in r24,0x5
  87 0046 8C63      		ori r24,lo8(60)
  88 0048 85B9      		out 0x5,r24
  57:ex3.c         ****     PORTB &= ~((1 << PINB0) | (1 << PINB1));
  89               		.loc 1 57 0
  90 004a 85B1      		in r24,0x5
  91 004c 8C7F      		andi r24,lo8(-4)
  92 004e 85B9      		out 0x5,r24
  58:ex3.c         ****     PORTD &= ~((1 << PIND6) | (1 << PIND7));
  93               		.loc 1 58 0
  94 0050 8BB1      		in r24,0xb
  95 0052 8F73      		andi r24,lo8(63)
  96 0054 8BB9      		out 0xb,r24
  97               	.LVL2:
  98               	.LBB25:
  99               	.LBB26:
 100               		.loc 2 187 0
 101 0056 8FE3      		ldi r24,lo8(-25537)
 102 0058 9CE9      		ldi r25,hi8(-25537)
 103 005a 0197      	1:	sbiw r24,1
 104 005c 01F4      		brne 1b
 105 005e 00C0      		rjmp .
 106 0060 0000      		nop
 107               	.LVL3:
 108 0062 0895      		ret
 109               	.LBE26:
 110               	.LBE25:
 111               		.cfi_endproc
 112               	.LFE12:
 114               		.section	.rodata
 115               	.LC0:
 116 0000 31        		.byte	49
 117 0001 32        		.byte	50
 118 0002 33        		.byte	51
 119 0003 41        		.byte	65
 120 0004 34        		.byte	52
 121 0005 35        		.byte	53
 122 0006 36        		.byte	54
 123 0007 42        		.byte	66
 124 0008 37        		.byte	55
 125 0009 38        		.byte	56
 126 000a 39        		.byte	57
 127 000b 43        		.byte	67
 128 000c 2A        		.byte	42
 129 000d 30        		.byte	48
 130 000e 23        		.byte	35
 131 000f 44        		.byte	68
 132               		.text
 133               	.global	getKeyPad
 135               	getKeyPad:
 136               	.LFB13:
  59:ex3.c         **** 
  60:ex3.c         ****     _delay_ms(10);
  61:ex3.c         **** }
  62:ex3.c         **** 
  63:ex3.c         **** char getKeyPad()
  64:ex3.c         **** {
 137               		.loc 1 64 0
 138               		.cfi_startproc
 139 0064 0F93      		push r16
 140               	.LCFI0:
 141               		.cfi_def_cfa_offset 3
 142               		.cfi_offset 16, -2
 143 0066 1F93      		push r17
 144               	.LCFI1:
 145               		.cfi_def_cfa_offset 4
 146               		.cfi_offset 17, -3
 147 0068 CF93      		push r28
 148               	.LCFI2:
 149               		.cfi_def_cfa_offset 5
 150               		.cfi_offset 28, -4
 151 006a DF93      		push r29
 152               	.LCFI3:
 153               		.cfi_def_cfa_offset 6
 154               		.cfi_offset 29, -5
 155 006c CDB7      		in r28,__SP_L__
 156 006e DEB7      		in r29,__SP_H__
 157               	.LCFI4:
 158               		.cfi_def_cfa_register 28
 159 0070 6097      		sbiw r28,16
 160               	.LCFI5:
 161               		.cfi_def_cfa_offset 22
 162 0072 0FB6      		in __tmp_reg__,__SREG__
 163 0074 F894      		cli
 164 0076 DEBF      		out __SP_H__,r29
 165 0078 0FBE      		out __SREG__,__tmp_reg__
 166 007a CDBF      		out __SP_L__,r28
 167               	/* prologue: function */
 168               	/* frame size = 16 */
 169               	/* stack size = 20 */
 170               	.L__stack_usage = 20
 171               	.LVL4:
  65:ex3.c         **** 
  66:ex3.c         ****     char key = ' ';
  67:ex3.c         ****     char keyPad[4][4] = {
 172               		.loc 1 67 0
 173 007c 80E1      		ldi r24,lo8(16)
 174 007e E0E0      		ldi r30,lo8(.LC0)
 175 0080 F0E0      		ldi r31,hi8(.LC0)
 176 0082 DE01      		movw r26,r28
 177 0084 1196      		adiw r26,1
 178               		0:
 179 0086 0190      		ld r0,Z+
 180 0088 0D92      		st X+,r0
 181 008a 8A95      		dec r24
 182 008c 01F4      		brne 0b
 183               	.LVL5:
 184               	.LBB27:
 185               	.LBB28:
 186               		.loc 2 187 0
 187 008e 8FE3      		ldi r24,lo8(-25537)
 188 0090 9CE9      		ldi r25,hi8(-25537)
 189 0092 0197      	1:	sbiw r24,1
 190 0094 01F4      		brne 1b
 191 0096 00C0      		rjmp .
 192 0098 0000      		nop
 193               	.LVL6:
 194               	.LBE28:
 195               	.LBE27:
  68:ex3.c         ****         {'1', '2', '3', 'A'},
  69:ex3.c         ****         {'4', '5', '6', 'B'},
  70:ex3.c         ****         {'7', '8', '9', 'C'},
  71:ex3.c         ****         {'*', '0', '#', 'D'}};
  72:ex3.c         **** 
  73:ex3.c         ****     int i = -1;
  74:ex3.c         ****     int j = -1;
  75:ex3.c         **** 
  76:ex3.c         ****     _delay_ms(10);
  77:ex3.c         ****     columnOutRowIn();
 196               		.loc 1 77 0
 197 009a 0E94 0000 		call columnOutRowIn
 198               	.LVL7:
 199               	.L5:
 200               	.LBB29:
 201               	.LBB30:
 202               		.loc 2 187 0
 203 009e 8FE3      		ldi r24,lo8(-25537)
 204 00a0 9CE9      		ldi r25,hi8(-25537)
 205 00a2 0197      	1:	sbiw r24,1
 206 00a4 01F4      		brne 1b
 207 00a6 00C0      		rjmp .
 208 00a8 0000      		nop
 209               	.LVL8:
 210               	.LBE30:
 211               	.LBE29:
  78:ex3.c         ****     while (i == -1)
  79:ex3.c         ****     {
  80:ex3.c         ****         _delay_ms(10);
  81:ex3.c         ****         if ((PINB & (1 << PINB2)))
 212               		.loc 1 81 0
 213 00aa 1A99      		sbic 0x3,2
 214 00ac 00C0      		rjmp .L12
  82:ex3.c         ****         {
  83:ex3.c         ****             i = 3;
  84:ex3.c         ****         }
  85:ex3.c         ****         else if ((PINB & (1 << PINB3)))
 215               		.loc 1 85 0
 216 00ae 1B99      		sbic 0x3,3
 217 00b0 00C0      		rjmp .L13
  86:ex3.c         ****         {
  87:ex3.c         ****             i = 2;
  88:ex3.c         ****         }
  89:ex3.c         ****         else if ((PINB & (1 << PINB4)))
 218               		.loc 1 89 0
 219 00b2 1C99      		sbic 0x3,4
 220 00b4 00C0      		rjmp .L14
 221               	.LVL9:
  78:ex3.c         ****     {
 222               		.loc 1 78 0
 223 00b6 1D9B      		sbis 0x3,5
 224 00b8 00C0      		rjmp .L5
  90:ex3.c         ****         {
  91:ex3.c         ****             i = 1;
  92:ex3.c         ****         }
  93:ex3.c         ****         else if ((PINB & (1 << PINB5)))
 225               		.loc 1 93 0
 226 00ba 00E0      		ldi r16,0
 227 00bc 10E0      		ldi r17,0
 228               	.L11:
 229               	.LVL10:
 230               	.LBB31:
 231               	.LBB32:
 232               		.loc 2 187 0
 233 00be 8FE3      		ldi r24,lo8(-25537)
 234 00c0 9CE9      		ldi r25,hi8(-25537)
 235 00c2 0197      	1:	sbiw r24,1
 236 00c4 01F4      		brne 1b
 237 00c6 00C0      		rjmp .
 238 00c8 0000      		nop
 239               	.LVL11:
 240               	.LBE32:
 241               	.LBE31:
  94:ex3.c         ****         {
  95:ex3.c         ****             i = 0;
  96:ex3.c         ****         }
  97:ex3.c         ****     }
  98:ex3.c         **** 
  99:ex3.c         ****     _delay_ms(10);
 100:ex3.c         **** 
 101:ex3.c         ****     columnInRowOut();
 242               		.loc 1 101 0
 243 00ca 0E94 0000 		call columnInRowOut
 244               	.LVL12:
 245               	.L10:
 246               	.LBB33:
 247               	.LBB34:
 248               		.loc 2 187 0
 249 00ce 8FE3      		ldi r24,lo8(-25537)
 250 00d0 9CE9      		ldi r25,hi8(-25537)
 251 00d2 0197      	1:	sbiw r24,1
 252 00d4 01F4      		brne 1b
 253 00d6 00C0      		rjmp .
 254 00d8 0000      		nop
 255 00da 8FEF      		ldi r24,lo8(-1)
 256 00dc 9FEF      		ldi r25,lo8(-1)
 257               	.LVL13:
 258               	.L6:
 259               	.LBE34:
 260               	.LBE33:
 102:ex3.c         ****     while (j == -1)
 103:ex3.c         ****     {
 104:ex3.c         ****         _delay_ms(10);
 105:ex3.c         ****         while ((PIND & (1 << PINB6)))
 261               		.loc 1 105 0
 262 00de 4E9B      		sbis 0x9,6
 263 00e0 00C0      		rjmp .L7
 106:ex3.c         ****         {
 107:ex3.c         ****             j = 3;
 264               		.loc 1 107 0
 265 00e2 83E0      		ldi r24,lo8(3)
 266 00e4 90E0      		ldi r25,0
 267               	.LVL14:
 268 00e6 00C0      		rjmp .L6
 269               	.L7:
 270               	.LVL15:
 108:ex3.c         ****         }
 109:ex3.c         ****         while ((PIND & (1 << PINB7)))
 271               		.loc 1 109 0
 272 00e8 4F9B      		sbis 0x9,7
 273 00ea 00C0      		rjmp .L8
 110:ex3.c         ****         {
 111:ex3.c         ****             j = 2;
 274               		.loc 1 111 0
 275 00ec 82E0      		ldi r24,lo8(2)
 276 00ee 90E0      		ldi r25,0
 277               	.LVL16:
 278 00f0 00C0      		rjmp .L7
 279               	.L8:
 280               	.LVL17:
 112:ex3.c         ****         }
 113:ex3.c         ****         while ((PINB & (1 << PINB0)))
 281               		.loc 1 113 0
 282 00f2 189B      		sbis 0x3,0
 283 00f4 00C0      		rjmp .L9
 114:ex3.c         ****         {
 115:ex3.c         ****             j = 1;
 284               		.loc 1 115 0
 285 00f6 81E0      		ldi r24,lo8(1)
 286 00f8 90E0      		ldi r25,0
 287               	.LVL18:
 288 00fa 00C0      		rjmp .L8
 289               	.L9:
 290               	.LVL19:
 116:ex3.c         ****         }
 117:ex3.c         ****         while ((PINB & (1 << PINB1)))
 291               		.loc 1 117 0
 292 00fc 199B      		sbis 0x3,1
 293 00fe 00C0      		rjmp .L25
 118:ex3.c         ****         {
 119:ex3.c         ****             j = 0;
 294               		.loc 1 119 0
 295 0100 80E0      		ldi r24,0
 296 0102 90E0      		ldi r25,0
 297               	.LVL20:
 298 0104 00C0      		rjmp .L9
 299               	.LVL21:
 300               	.L25:
 102:ex3.c         ****     {
 301               		.loc 1 102 0
 302 0106 8F3F      		cpi r24,-1
 303 0108 2FEF      		ldi r18,-1
 304 010a 9207      		cpc r25,r18
 305 010c 01F0      		breq .L10
 306               	.LVL22:
 307               	.LBB35:
 308               	.LBB36:
 309               		.loc 2 187 0
 310 010e 3FEF      		ldi r19,lo8(319999)
 311 0110 41EE      		ldi r20,hi8(319999)
 312 0112 24E0      		ldi r18,hlo8(319999)
 313 0114 3150      	1:	subi r19,1
 314 0116 4040      		sbci r20,0
 315 0118 2040      		sbci r18,0
 316 011a 01F4      		brne 1b
 317 011c 00C0      		rjmp .
 318 011e 0000      		nop
 319               	.LVL23:
 320               	.LBE36:
 321               	.LBE35:
 120:ex3.c         ****         }
 121:ex3.c         ****     }
 122:ex3.c         **** 
 123:ex3.c         ****     _delay_ms(100);
 124:ex3.c         **** 
 125:ex3.c         ****     // usart_send_string("i, j - ");
 126:ex3.c         ****     // usart_send_int(i);
 127:ex3.c         ****     // usart_send(',');
 128:ex3.c         ****     // usart_send_int(j);
 129:ex3.c         ****     // usart_send('\n');
 130:ex3.c         **** 
 131:ex3.c         ****     // usart_send_string("values - ");
 132:ex3.c         ****     // usart_send(keyPad[i][j]);
 133:ex3.c         ****     // usart_send('\n');
 134:ex3.c         **** 
 135:ex3.c         ****     return keyPad[i][j];
 322               		.loc 1 135 0
 323 0120 000F      		lsl r16
 324 0122 111F      		rol r17
 325 0124 000F      		lsl r16
 326 0126 111F      		rol r17
 327               	.LVL24:
 328 0128 21E0      		ldi r18,lo8(1)
 329 012a 30E0      		ldi r19,0
 330 012c 2C0F      		add r18,r28
 331 012e 3D1F      		adc r19,r29
 332 0130 020F      		add r16,r18
 333 0132 131F      		adc r17,r19
 334 0134 F801      		movw r30,r16
 335 0136 E80F      		add r30,r24
 336 0138 F91F      		adc r31,r25
 337 013a 8081      		ld r24,Z
 338               	.LVL25:
 339               	/* epilogue start */
 136:ex3.c         **** }
 340               		.loc 1 136 0
 341 013c 6096      		adiw r28,16
 342 013e 0FB6      		in __tmp_reg__,__SREG__
 343 0140 F894      		cli
 344 0142 DEBF      		out __SP_H__,r29
 345 0144 0FBE      		out __SREG__,__tmp_reg__
 346 0146 CDBF      		out __SP_L__,r28
 347 0148 DF91      		pop r29
 348 014a CF91      		pop r28
 349 014c 1F91      		pop r17
 350 014e 0F91      		pop r16
 351 0150 0895      		ret
 352               	.LVL26:
 353               	.L12:
  83:ex3.c         ****         }
 354               		.loc 1 83 0
 355 0152 03E0      		ldi r16,lo8(3)
 356 0154 10E0      		ldi r17,0
 357 0156 00C0      		rjmp .L11
 358               	.L13:
  87:ex3.c         ****         }
 359               		.loc 1 87 0
 360 0158 02E0      		ldi r16,lo8(2)
 361 015a 10E0      		ldi r17,0
 362 015c 00C0      		rjmp .L11
 363               	.L14:
  91:ex3.c         ****         }
 364               		.loc 1 91 0
 365 015e 01E0      		ldi r16,lo8(1)
 366 0160 10E0      		ldi r17,0
 367               	.LVL27:
 368 0162 00C0      		rjmp .L11
 369               		.cfi_endproc
 370               	.LFE13:
 372               	.global	EEPROMwrite
 374               	EEPROMwrite:
 375               	.LFB14:
 137:ex3.c         **** 
 138:ex3.c         **** void EEPROMwrite(unsigned int address, char data)
 139:ex3.c         **** {
 376               		.loc 1 139 0
 377               		.cfi_startproc
 378               	/* prologue: function */
 379               	/* frame size = 0 */
 380               	/* stack size = 0 */
 381               	.L__stack_usage = 0
 382               	.LVL28:
 383               	.L27:
 140:ex3.c         ****     // wait for completion of previous write
 141:ex3.c         ****     while (EECR & (1 << EEPE))
 384               		.loc 1 141 0 discriminator 1
 385 0164 F999      		sbic 0x1f,1
 386 0166 00C0      		rjmp .L27
 142:ex3.c         ****         ;
 143:ex3.c         **** 
 144:ex3.c         ****     EEAR = address;
 387               		.loc 1 144 0
 388 0168 92BD      		out 0x21+1,r25
 389 016a 81BD      		out 0x21,r24
 145:ex3.c         ****     EEDR = data;
 390               		.loc 1 145 0
 391 016c 60BD      		out 0x20,r22
 146:ex3.c         **** 
 147:ex3.c         ****     // write logical one to EEMPE
 148:ex3.c         ****     EECR |= (1 << EEMPE);
 392               		.loc 1 148 0
 393 016e FA9A      		sbi 0x1f,2
 149:ex3.c         **** 
 150:ex3.c         ****     // start eeprom write by setting EEPE
 151:ex3.c         ****     EECR |= (1 << EEPE);
 394               		.loc 1 151 0
 395 0170 F99A      		sbi 0x1f,1
 396 0172 0895      		ret
 397               		.cfi_endproc
 398               	.LFE14:
 400               	.global	EEPROMwriteString
 402               	EEPROMwriteString:
 403               	.LFB15:
 152:ex3.c         **** }
 153:ex3.c         **** 
 154:ex3.c         **** void EEPROMwriteString(unsigned int address, char *sen)
 155:ex3.c         **** {
 404               		.loc 1 155 0
 405               		.cfi_startproc
 406               	.LVL29:
 407 0174 EF92      		push r14
 408               	.LCFI6:
 409               		.cfi_def_cfa_offset 3
 410               		.cfi_offset 14, -2
 411 0176 FF92      		push r15
 412               	.LCFI7:
 413               		.cfi_def_cfa_offset 4
 414               		.cfi_offset 15, -3
 415 0178 0F93      		push r16
 416               	.LCFI8:
 417               		.cfi_def_cfa_offset 5
 418               		.cfi_offset 16, -4
 419 017a 1F93      		push r17
 420               	.LCFI9:
 421               		.cfi_def_cfa_offset 6
 422               		.cfi_offset 17, -5
 423 017c CF93      		push r28
 424               	.LCFI10:
 425               		.cfi_def_cfa_offset 7
 426               		.cfi_offset 28, -6
 427 017e DF93      		push r29
 428               	.LCFI11:
 429               		.cfi_def_cfa_offset 8
 430               		.cfi_offset 29, -7
 431               	/* prologue: function */
 432               	/* frame size = 0 */
 433               	/* stack size = 6 */
 434               	.L__stack_usage = 6
 435 0180 7C01      		movw r14,r24
 436 0182 8B01      		movw r16,r22
 437               	.LVL30:
 156:ex3.c         ****     int i = 0;
 438               		.loc 1 156 0
 439 0184 C0E0      		ldi r28,0
 440 0186 D0E0      		ldi r29,0
 441               	.LVL31:
 442               	.L30:
 157:ex3.c         ****     while (sen[i] != '\0')
 443               		.loc 1 157 0
 444 0188 F801      		movw r30,r16
 445 018a 6191      		ld r22,Z+
 446 018c 8F01      		movw r16,r30
 447 018e CE01      		movw r24,r28
 448 0190 8E0D      		add r24,r14
 449 0192 9F1D      		adc r25,r15
 450 0194 6623      		tst r22
 451 0196 01F0      		breq .L32
 158:ex3.c         ****     {
 159:ex3.c         ****         EEPROMwrite(address + i, sen[i]);
 452               		.loc 1 159 0
 453 0198 0E94 0000 		call EEPROMwrite
 454               	.LVL32:
 160:ex3.c         ****         i++;
 455               		.loc 1 160 0
 456 019c 2196      		adiw r28,1
 457               	.LVL33:
 458 019e 00C0      		rjmp .L30
 459               	.L32:
 460               	/* epilogue start */
 161:ex3.c         ****     }
 162:ex3.c         ****     EEPROMwrite(address + i, '\0');
 163:ex3.c         **** }
 461               		.loc 1 163 0
 462 01a0 DF91      		pop r29
 463 01a2 CF91      		pop r28
 464               	.LVL34:
 465 01a4 1F91      		pop r17
 466 01a6 0F91      		pop r16
 467 01a8 FF90      		pop r15
 468 01aa EF90      		pop r14
 469               	.LVL35:
 162:ex3.c         **** }
 470               		.loc 1 162 0
 471 01ac 0C94 0000 		jmp EEPROMwrite
 472               	.LVL36:
 473               		.cfi_endproc
 474               	.LFE15:
 476               	.global	EEPROMread
 478               	EEPROMread:
 479               	.LFB16:
 164:ex3.c         **** 
 165:ex3.c         **** char EEPROMread(unsigned int address)
 166:ex3.c         **** {
 480               		.loc 1 166 0
 481               		.cfi_startproc
 482               	/* prologue: function */
 483               	/* frame size = 0 */
 484               	/* stack size = 0 */
 485               	.L__stack_usage = 0
 486               	.LVL37:
 487               	.L34:
 167:ex3.c         **** 
 168:ex3.c         ****     while (EECR & (1 << EEPE))
 488               		.loc 1 168 0 discriminator 1
 489 01b0 F999      		sbic 0x1f,1
 490 01b2 00C0      		rjmp .L34
 169:ex3.c         ****         ;
 170:ex3.c         **** 
 171:ex3.c         ****     EEAR = address;
 491               		.loc 1 171 0
 492 01b4 92BD      		out 0x21+1,r25
 493 01b6 81BD      		out 0x21,r24
 172:ex3.c         **** 
 173:ex3.c         ****     EECR |= (1 << EERE);
 494               		.loc 1 173 0
 495 01b8 F89A      		sbi 0x1f,0
 174:ex3.c         **** 
 175:ex3.c         ****     return EEDR;
 496               		.loc 1 175 0
 497 01ba 80B5      		in r24,0x20
 498               	.LVL38:
 176:ex3.c         **** }
 499               		.loc 1 176 0
 500 01bc 0895      		ret
 501               		.cfi_endproc
 502               	.LFE16:
 504               	.global	EEPROMreadString
 506               	EEPROMreadString:
 507               	.LFB17:
 177:ex3.c         **** 
 178:ex3.c         **** void EEPROMreadString(unsigned int address, char *sen)
 179:ex3.c         **** {
 508               		.loc 1 179 0
 509               		.cfi_startproc
 510               	.LVL39:
 511 01be EF92      		push r14
 512               	.LCFI12:
 513               		.cfi_def_cfa_offset 3
 514               		.cfi_offset 14, -2
 515 01c0 FF92      		push r15
 516               	.LCFI13:
 517               		.cfi_def_cfa_offset 4
 518               		.cfi_offset 15, -3
 519 01c2 0F93      		push r16
 520               	.LCFI14:
 521               		.cfi_def_cfa_offset 5
 522               		.cfi_offset 16, -4
 523 01c4 1F93      		push r17
 524               	.LCFI15:
 525               		.cfi_def_cfa_offset 6
 526               		.cfi_offset 17, -5
 527 01c6 CF93      		push r28
 528               	.LCFI16:
 529               		.cfi_def_cfa_offset 7
 530               		.cfi_offset 28, -6
 531 01c8 DF93      		push r29
 532               	.LCFI17:
 533               		.cfi_def_cfa_offset 8
 534               		.cfi_offset 29, -7
 535               	/* prologue: function */
 536               	/* frame size = 0 */
 537               	/* stack size = 6 */
 538               	.L__stack_usage = 6
 539 01ca 8C01      		movw r16,r24
 540 01cc 7B01      		movw r14,r22
 541               	.LVL40:
 180:ex3.c         ****     int i = 0;
 181:ex3.c         ****     char c = EEPROMread(address + i);
 542               		.loc 1 181 0
 543 01ce 0E94 0000 		call EEPROMread
 544               	.LVL41:
 182:ex3.c         ****     sen[i] = c;
 545               		.loc 1 182 0
 546 01d2 E701      		movw r28,r14
 547 01d4 8993      		st Y+,r24
 183:ex3.c         **** 
 184:ex3.c         ****     while (c != '\0')
 185:ex3.c         ****     {
 186:ex3.c         **** 
 187:ex3.c         ****         i++;
 188:ex3.c         ****         c = EEPROMread(address + i);
 548               		.loc 1 188 0
 549 01d6 0E19      		sub r16,r14
 550 01d8 1F09      		sbc r17,r15
 551               	.LVL42:
 552               	.L37:
 184:ex3.c         ****     {
 553               		.loc 1 184 0
 554 01da 8823      		tst r24
 555 01dc 01F0      		breq .L39
 556               	.LVL43:
 557               		.loc 1 188 0
 558 01de C801      		movw r24,r16
 559               	.LVL44:
 560 01e0 8C0F      		add r24,r28
 561 01e2 9D1F      		adc r25,r29
 562 01e4 0E94 0000 		call EEPROMread
 563               	.LVL45:
 189:ex3.c         ****         sen[i] = c;
 564               		.loc 1 189 0
 565 01e8 8993      		st Y+,r24
 566               	.LVL46:
 567 01ea 00C0      		rjmp .L37
 568               	.L39:
 569               	/* epilogue start */
 190:ex3.c         ****     }
 191:ex3.c         **** }
 570               		.loc 1 191 0
 571 01ec DF91      		pop r29
 572 01ee CF91      		pop r28
 573               	.LVL47:
 574 01f0 1F91      		pop r17
 575 01f2 0F91      		pop r16
 576 01f4 FF90      		pop r15
 577 01f6 EF90      		pop r14
 578               	.LVL48:
 579 01f8 0895      		ret
 580               		.cfi_endproc
 581               	.LFE17:
 583               		.section	.rodata.str1.1,"aMS",@progbits,1
 584               	.LC1:
 585 0000 5072 6573 		.string	"Press 1 or 2\n"
 585      7320 3120 
 585      6F72 2032 
 585      0A00 
 586               	.LC2:
 587 000e 2845 6E63 		.string	"(Encrypt/Key)\n"
 587      7279 7074 
 587      2F4B 6579 
 587      290A 00
 588               	.LC3:
 589 001d 5072 6F63 		.string	"Processing...\n"
 589      6573 7369 
 589      6E67 2E2E 
 589      2E0A 00
 590               	.LC4:
 591 002c 5072 6573 		.string	"Press any Con\n"
 591      7320 616E 
 591      7920 436F 
 591      6E0A 00
 592               	.LC5:
 593 003b 456E 7465 		.string	"Enter the Key\n"
 593      7220 7468 
 593      6520 4B65 
 593      790A 00
 594               	.LC6:
 595 004a 4B65 7920 		.string	"Key is Saved!!!\n"
 595      6973 2053 
 595      6176 6564 
 595      2121 210A 
 595      00
 596               		.section	.text.startup,"ax",@progbits
 597               	.global	main
 599               	main:
 600               	.LFB18:
 192:ex3.c         **** 
 193:ex3.c         **** int main(void)
 194:ex3.c         **** {
 601               		.loc 1 194 0
 602               		.cfi_startproc
 603 0000 CF93      		push r28
 604               	.LCFI18:
 605               		.cfi_def_cfa_offset 3
 606               		.cfi_offset 28, -2
 607 0002 DF93      		push r29
 608               	.LCFI19:
 609               		.cfi_def_cfa_offset 4
 610               		.cfi_offset 29, -3
 611 0004 CDB7      		in r28,__SP_L__
 612 0006 DEB7      		in r29,__SP_H__
 613               	.LCFI20:
 614               		.cfi_def_cfa_register 28
 615 0008 2B97      		sbiw r28,11
 616               	.LCFI21:
 617               		.cfi_def_cfa_offset 15
 618 000a 0FB6      		in __tmp_reg__,__SREG__
 619 000c F894      		cli
 620 000e DEBF      		out __SP_H__,r29
 621 0010 0FBE      		out __SREG__,__tmp_reg__
 622 0012 CDBF      		out __SP_L__,r28
 623               	/* prologue: function */
 624               	/* frame size = 11 */
 625               	/* stack size = 13 */
 626               	.L__stack_usage = 13
 195:ex3.c         **** 
 196:ex3.c         ****     /* initialize display, cursor off */
 197:ex3.c         ****     lcd_init(LCD_DISP_ON);
 627               		.loc 1 197 0
 628 0014 8CE0      		ldi r24,lo8(12)
 629 0016 0E94 0000 		call lcd_init
 630               	.LVL49:
 631               	.L41:
 198:ex3.c         ****     int row, col;
 199:ex3.c         **** 
 200:ex3.c         ****     char keyString[SIZE + 1];
 201:ex3.c         **** 
 202:ex3.c         ****     while (1)
 203:ex3.c         ****     {
 204:ex3.c         ****         /* clear display and home cursor */
 205:ex3.c         ****         lcd_clrscr();
 632               		.loc 1 205 0
 633 001a 0E94 0000 		call lcd_clrscr
 634               	.LVL50:
 206:ex3.c         **** 
 207:ex3.c         ****         // need to encryp or change the key
 208:ex3.c         ****         lcd_gotoxy(0, 0);
 635               		.loc 1 208 0
 636 001e 60E0      		ldi r22,0
 637 0020 80E0      		ldi r24,0
 638 0022 0E94 0000 		call lcd_gotoxy
 639               	.LVL51:
 209:ex3.c         ****         lcd_puts("Press 1 or 2\n");
 640               		.loc 1 209 0
 641 0026 80E0      		ldi r24,lo8(.LC1)
 642 0028 90E0      		ldi r25,hi8(.LC1)
 643 002a 0E94 0000 		call lcd_puts
 644               	.LVL52:
 210:ex3.c         ****         lcd_gotoxy(0, 1);
 645               		.loc 1 210 0
 646 002e 61E0      		ldi r22,lo8(1)
 647 0030 80E0      		ldi r24,0
 648 0032 0E94 0000 		call lcd_gotoxy
 649               	.LVL53:
 211:ex3.c         ****         lcd_puts("(Encrypt/Key)\n");
 650               		.loc 1 211 0
 651 0036 80E0      		ldi r24,lo8(.LC2)
 652 0038 90E0      		ldi r25,hi8(.LC2)
 653 003a 0E94 0000 		call lcd_puts
 654               	.LVL54:
 212:ex3.c         **** 
 213:ex3.c         ****         // wait for user input
 214:ex3.c         ****         input = getKeyPad();
 655               		.loc 1 214 0
 656 003e 0E94 0000 		call getKeyPad
 657               	.LVL55:
 658 0042 8093 0000 		sts input,r24
 215:ex3.c         **** 
 216:ex3.c         ****         lcd_clrscr();
 659               		.loc 1 216 0
 660 0046 0E94 0000 		call lcd_clrscr
 661               	.LVL56:
 217:ex3.c         **** 
 218:ex3.c         ****         if (input == '1')
 662               		.loc 1 218 0
 663 004a 8091 0000 		lds r24,input
 664 004e 8133      		cpi r24,lo8(49)
 665 0050 01F0      		breq .+2
 666 0052 00C0      		rjmp .L42
 667 0054 00E0      		ldi r16,lo8(buffer)
 668 0056 10E0      		ldi r17,hi8(buffer)
 669 0058 6801      		movw r12,r16
 670 005a FF24      		clr r15
 671 005c F394      		inc r15
 672               	.L43:
 673               	.LVL57:
 674               	.LBB37:
 219:ex3.c         ****         {
 220:ex3.c         **** 
 221:ex3.c         ****             row = 0;
 222:ex3.c         ****             col = 0;
 223:ex3.c         ****             for (int i = 0; i < SIZE; i++)
 224:ex3.c         ****             {
 225:ex3.c         ****                 // wait for user input
 226:ex3.c         ****                 input = getKeyPad();
 675               		.loc 1 226 0 discriminator 3
 676 005e 0E94 0000 		call getKeyPad
 677               	.LVL58:
 678 0062 8093 0000 		sts input,r24
 227:ex3.c         **** 
 228:ex3.c         ****                 /* write single char to display */
 229:ex3.c         ****                 lcd_putc(input);
 679               		.loc 1 229 0 discriminator 3
 680 0066 0E94 0000 		call lcd_putc
 681               	.LVL59:
 230:ex3.c         ****                 buffer[i] = input;
 682               		.loc 1 230 0 discriminator 3
 683 006a 8091 0000 		lds r24,input
 684 006e F601      		movw r30,r12
 685 0070 8193      		st Z+,r24
 686 0072 6F01      		movw r12,r30
 687               	.LVL60:
 231:ex3.c         **** 
 232:ex3.c         ****                 col++;
 233:ex3.c         ****                 lcd_gotoxy(col, row);
 688               		.loc 1 233 0 discriminator 3
 689 0074 60E0      		ldi r22,0
 690 0076 8F2D      		mov r24,r15
 691 0078 0E94 0000 		call lcd_gotoxy
 692               	.LVL61:
 693 007c F394      		inc r15
 223:ex3.c         ****             {
 694               		.loc 1 223 0 discriminator 3
 695 007e FBE0      		ldi r31,lo8(11)
 696 0080 FF12      		cpse r15,r31
 697 0082 00C0      		rjmp .L43
 698               	.LBE37:
 234:ex3.c         ****             }
 235:ex3.c         **** 
 236:ex3.c         ****             // _delay_ms(1000);
 237:ex3.c         **** 
 238:ex3.c         ****             buffer[SIZE] = '\0';
 699               		.loc 1 238 0
 700 0084 1092 0000 		sts buffer+10,__zero_reg__
 239:ex3.c         **** 
 240:ex3.c         ****             lcd_clrscr();
 701               		.loc 1 240 0
 702 0088 0E94 0000 		call lcd_clrscr
 703               	.LVL62:
 241:ex3.c         **** 
 242:ex3.c         ****             lcd_puts("Processing...\n");
 704               		.loc 1 242 0
 705 008c 80E0      		ldi r24,lo8(.LC3)
 706 008e 90E0      		ldi r25,hi8(.LC3)
 707 0090 0E94 0000 		call lcd_puts
 708               	.LVL63:
 709               	.LBB38:
 710               	.LBB39:
 711               		.loc 2 187 0
 712 0094 2FEF      		ldi r18,lo8(3199999)
 713 0096 83ED      		ldi r24,hi8(3199999)
 714 0098 90E3      		ldi r25,hlo8(3199999)
 715 009a 2150      	1:	subi r18,1
 716 009c 8040      		sbci r24,0
 717 009e 9040      		sbci r25,0
 718 00a0 01F4      		brne 1b
 719 00a2 00C0      		rjmp .
 720 00a4 0000      		nop
 721               	.LVL64:
 722               	.LBE39:
 723               	.LBE38:
 243:ex3.c         ****             _delay_ms(1000);
 244:ex3.c         **** 
 245:ex3.c         ****             lcd_clrscr();
 724               		.loc 1 245 0
 725 00a6 0E94 0000 		call lcd_clrscr
 726               	.LVL65:
 246:ex3.c         **** 
 247:ex3.c         ****             EEPROMreadString(ADDRESS, keyString);
 727               		.loc 1 247 0
 728 00aa BE01      		movw r22,r28
 729 00ac 6F5F      		subi r22,-1
 730 00ae 7F4F      		sbci r23,-1
 731 00b0 80E0      		ldi r24,0
 732 00b2 90E0      		ldi r25,0
 733 00b4 0E94 0000 		call EEPROMreadString
 734               	.LVL66:
 248:ex3.c         **** 
 249:ex3.c         ****             key = atoi(keyString);
 735               		.loc 1 249 0
 736 00b8 CE01      		movw r24,r28
 737 00ba 0196      		adiw r24,1
 738 00bc 0E94 0000 		call atoi
 739               	.LVL67:
 740 00c0 8093 0000 		sts key,r24
 741 00c4 9093 0000 		sts key+1,r25
 742               	.LVL68:
 743               	.L44:
 744               	.LBB40:
 250:ex3.c         **** 
 251:ex3.c         ****             for (int i = 0; i < SIZE; i++)
 252:ex3.c         ****             {
 253:ex3.c         ****                 buffer[i] = buffer[i] + key;
 745               		.loc 1 253 0 discriminator 3
 746 00c8 F801      		movw r30,r16
 747 00ca 9081      		ld r25,Z
 748 00cc 980F      		add r25,r24
 749 00ce 9193      		st Z+,r25
 750 00d0 8F01      		movw r16,r30
 751               	.LVL69:
 251:ex3.c         ****             {
 752               		.loc 1 251 0 discriminator 3
 753 00d2 F0E0      		ldi r31,hi8(buffer+10)
 754 00d4 0030      		cpi r16,lo8(buffer+10)
 755 00d6 1F07      		cpc r17,r31
 756 00d8 01F4      		brne .L44
 757               	.LBE40:
 254:ex3.c         ****             }
 255:ex3.c         **** 
 256:ex3.c         ****             // _delay_ms(1000);
 257:ex3.c         ****             lcd_puts(buffer);
 758               		.loc 1 257 0
 759 00da 80E0      		ldi r24,lo8(buffer)
 760 00dc 90E0      		ldi r25,hi8(buffer)
 761 00de 0E94 0000 		call lcd_puts
 762               	.LVL70:
 258:ex3.c         **** 
 259:ex3.c         ****             lcd_gotoxy(0, 1);
 763               		.loc 1 259 0
 764 00e2 61E0      		ldi r22,lo8(1)
 765 00e4 80E0      		ldi r24,0
 766 00e6 0E94 0000 		call lcd_gotoxy
 767               	.LVL71:
 260:ex3.c         ****             lcd_puts("Press any Con\n");
 768               		.loc 1 260 0
 769 00ea 80E0      		ldi r24,lo8(.LC4)
 770 00ec 90E0      		ldi r25,hi8(.LC4)
 771 00ee 0E94 0000 		call lcd_puts
 772               	.LVL72:
 261:ex3.c         **** 
 262:ex3.c         ****             input = getKeyPad();
 773               		.loc 1 262 0
 774 00f2 0E94 0000 		call getKeyPad
 775               	.LVL73:
 776 00f6 8093 0000 		sts input,r24
 263:ex3.c         **** 
 264:ex3.c         ****             lcd_clrscr();
 777               		.loc 1 264 0
 778 00fa 0E94 0000 		call lcd_clrscr
 779               	.LVL74:
 780 00fe 00C0      		rjmp .L41
 781               	.LVL75:
 782               	.L42:
 265:ex3.c         ****         }
 266:ex3.c         ****         else if (input == '2')
 783               		.loc 1 266 0
 784 0100 8233      		cpi r24,lo8(50)
 785 0102 01F0      		breq .+2
 786 0104 00C0      		rjmp .L41
 787               	.LBB41:
 267:ex3.c         ****         {
 268:ex3.c         ****             lcd_gotoxy(0, 0);
 788               		.loc 1 268 0
 789 0106 60E0      		ldi r22,0
 790 0108 80E0      		ldi r24,0
 791 010a 0E94 0000 		call lcd_gotoxy
 792               	.LVL76:
 269:ex3.c         ****             lcd_puts("Enter the Key\n");
 793               		.loc 1 269 0
 794 010e 80E0      		ldi r24,lo8(.LC5)
 795 0110 90E0      		ldi r25,hi8(.LC5)
 796 0112 0E94 0000 		call lcd_puts
 797               	.LVL77:
 270:ex3.c         **** 
 271:ex3.c         ****             row = 0;
 272:ex3.c         ****             col = 0;
 273:ex3.c         ****             int len = 0;
 274:ex3.c         **** 
 275:ex3.c         ****             lcd_gotoxy(0, 1);
 798               		.loc 1 275 0
 799 0116 61E0      		ldi r22,lo8(1)
 800 0118 80E0      		ldi r24,0
 801 011a 0E94 0000 		call lcd_gotoxy
 802               	.LVL78:
 803 011e 80E0      		ldi r24,lo8(buffer)
 804 0120 E82E      		mov r14,r24
 805 0122 80E0      		ldi r24,hi8(buffer)
 806 0124 F82E      		mov r15,r24
 272:ex3.c         ****             int len = 0;
 807               		.loc 1 272 0
 808 0126 00E0      		ldi r16,0
 809 0128 10E0      		ldi r17,0
 810               	.LVL79:
 811               	.L47:
 276:ex3.c         ****             row++;
 277:ex3.c         ****             for (;;)
 278:ex3.c         ****             {
 279:ex3.c         **** 
 280:ex3.c         ****                 // wait for user input
 281:ex3.c         ****                 input = getKeyPad();
 812               		.loc 1 281 0
 813 012a 0E94 0000 		call getKeyPad
 814               	.LVL80:
 815 012e 8093 0000 		sts input,r24
 282:ex3.c         **** 
 283:ex3.c         ****                 if (input == '#')
 816               		.loc 1 283 0
 817 0132 8332      		cpi r24,lo8(35)
 818 0134 01F0      		breq .L46
 284:ex3.c         ****                     break;
 285:ex3.c         **** 
 286:ex3.c         ****                 /* write single char to display */
 287:ex3.c         ****                 lcd_putc(input);
 819               		.loc 1 287 0
 820 0136 0E94 0000 		call lcd_putc
 821               	.LVL81:
 288:ex3.c         ****                 buffer[len] = input;
 822               		.loc 1 288 0
 823 013a 8091 0000 		lds r24,input
 824 013e F701      		movw r30,r14
 825 0140 8193      		st Z+,r24
 826 0142 7F01      		movw r14,r30
 827               	.LVL82:
 289:ex3.c         **** 
 290:ex3.c         ****                 len++;
 291:ex3.c         ****                 col++;
 828               		.loc 1 291 0
 829 0144 0F5F      		subi r16,-1
 830 0146 1F4F      		sbci r17,-1
 831               	.LVL83:
 292:ex3.c         ****                 lcd_gotoxy(col, row);
 832               		.loc 1 292 0
 833 0148 61E0      		ldi r22,lo8(1)
 834 014a 802F      		mov r24,r16
 835 014c 0E94 0000 		call lcd_gotoxy
 836               	.LVL84:
 293:ex3.c         ****             }
 837               		.loc 1 293 0
 838 0150 00C0      		rjmp .L47
 839               	.L46:
 294:ex3.c         **** 
 295:ex3.c         ****             lcd_clrscr();
 840               		.loc 1 295 0
 841 0152 0E94 0000 		call lcd_clrscr
 842               	.LVL85:
 296:ex3.c         ****             // _delay_ms(1000);
 297:ex3.c         ****             buffer[len] = '\0';
 843               		.loc 1 297 0
 844 0156 F801      		movw r30,r16
 845 0158 E050      		subi r30,lo8(-(buffer))
 846 015a F040      		sbci r31,hi8(-(buffer))
 847 015c 1082      		st Z,__zero_reg__
 298:ex3.c         **** 
 299:ex3.c         ****             EEPROMwriteString(ADDRESS, buffer);
 848               		.loc 1 299 0
 849 015e 60E0      		ldi r22,lo8(buffer)
 850 0160 70E0      		ldi r23,hi8(buffer)
 851 0162 80E0      		ldi r24,0
 852 0164 90E0      		ldi r25,0
 853 0166 0E94 0000 		call EEPROMwriteString
 854               	.LVL86:
 300:ex3.c         **** 
 301:ex3.c         ****             lcd_gotoxy(0, 0);
 855               		.loc 1 301 0
 856 016a 60E0      		ldi r22,0
 857 016c 80E0      		ldi r24,0
 858 016e 0E94 0000 		call lcd_gotoxy
 859               	.LVL87:
 302:ex3.c         **** 
 303:ex3.c         ****             lcd_puts("Key is Saved!!!\n");
 860               		.loc 1 303 0
 861 0172 80E0      		ldi r24,lo8(.LC6)
 862 0174 90E0      		ldi r25,hi8(.LC6)
 863 0176 0E94 0000 		call lcd_puts
 864               	.LVL88:
 865               	.LBB42:
 866               	.LBB43:
 867               		.loc 2 187 0
 868 017a FFEF      		ldi r31,lo8(3199999)
 869 017c 23ED      		ldi r18,hi8(3199999)
 870 017e 80E3      		ldi r24,hlo8(3199999)
 871 0180 F150      	1:	subi r31,1
 872 0182 2040      		sbci r18,0
 873 0184 8040      		sbci r24,0
 874 0186 01F4      		brne 1b
 875 0188 00C0      		rjmp .
 876 018a 0000      		nop
 877 018c 00C0      		rjmp .L41
 878               	.LBE43:
 879               	.LBE42:
 880               	.LBE41:
 881               		.cfi_endproc
 882               	.LFE18:
 884               	.global	input
 885               		.data
 888               	input:
 889 0000 32        		.byte	50
 890               		.comm	key,2,1
 891               	.global	buffer
 894               	buffer:
 895 0001 3132 3334 		.string	"1234567890"
 895      3536 3738 
 895      3930 00
 896               		.text
 897               	.Letext0:
 898               		.file 3 "/usr/lib/avr/include/stdint.h"
 899               		.file 4 "lcd.h"
 900               		.file 5 "/usr/lib/avr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ex3.c
               ex3.s:2      *ABS*:000000000000003e __SP_H__
               ex3.s:3      *ABS*:000000000000003d __SP_L__
               ex3.s:4      *ABS*:000000000000003f __SREG__
               ex3.s:5      *ABS*:0000000000000000 __tmp_reg__
               ex3.s:6      *ABS*:0000000000000001 __zero_reg__
               ex3.s:12     .text:0000000000000000 columnOutRowIn
               ex3.s:65     .text:0000000000000032 columnInRowOut
               ex3.s:135    .text:0000000000000064 getKeyPad
               ex3.s:374    .text:0000000000000164 EEPROMwrite
               ex3.s:402    .text:0000000000000174 EEPROMwriteString
               ex3.s:478    .text:00000000000001b0 EEPROMread
               ex3.s:506    .text:00000000000001be EEPROMreadString
               ex3.s:599    .text.startup:0000000000000000 main
               ex3.s:888    .data:0000000000000000 input
               ex3.s:894    .data:0000000000000001 buffer
                            *COM*:0000000000000002 key

UNDEFINED SYMBOLS
lcd_init
lcd_clrscr
lcd_gotoxy
lcd_puts
lcd_putc
atoi
__do_copy_data
__do_clear_bss
