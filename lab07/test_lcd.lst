   1               		.file	"test_lcd.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.rodata.str1.1,"aMS",@progbits,1
  11               	.LC0:
  12 0000 4C43 4420 		.string	"LCD Test 5\n"
  12      5465 7374 
  12      2035 0A00 
  13               	.LC1:
  14 000c 4375 724F 		.string	"CurOn"
  14      6E00 
  15               	.LC2:
  16 0012 436F 7079 		.string	"Copyright: "
  16      7269 6768 
  16      743A 2000 
  17               		.section	.text.startup,"ax",@progbits
  18               	.global	main
  20               	main:
  21               	.LFB11:
  22               		.file 1 "test_lcd.c"
   1:test_lcd.c    **** /*************************************************************************
   2:test_lcd.c    **** Title:    Testing output to a HD44780 based LCD display.
   3:test_lcd.c    **** Author:   Peter Fleury  <pfleury@gmx.ch>  http://tinyurl.com/peterfleury
   4:test_lcd.c    **** File:     $Id: test_lcd.c,v 1.8 2015/01/31 18:04:08 peter Exp $
   5:test_lcd.c    **** Software: AVR-GCC 4.x
   6:test_lcd.c    **** Hardware: HD44780 compatible LCD text display
   7:test_lcd.c    ****           AVR with external SRAM interface if memory-mapped LCD interface is used
   8:test_lcd.c    ****           any AVR with 7 free I/O pins if 4-bit IO port mode is used
   9:test_lcd.c    **** **************************************************************************/
  10:test_lcd.c    **** #include <stdlib.h>
  11:test_lcd.c    **** #include <avr/io.h>
  12:test_lcd.c    **** #include <avr/pgmspace.h>
  13:test_lcd.c    **** #include <util/delay.h>
  14:test_lcd.c    **** #include "lcd.h"
  15:test_lcd.c    **** 
  16:test_lcd.c    **** 
  17:test_lcd.c    **** /*
  18:test_lcd.c    **** ** constant definitions
  19:test_lcd.c    **** */
  20:test_lcd.c    **** static const PROGMEM unsigned char copyRightChar[] =
  21:test_lcd.c    **** {
  22:test_lcd.c    **** 	0x07, 0x08, 0x13, 0x14, 0x14, 0x13, 0x08, 0x07,
  23:test_lcd.c    **** 	0x00, 0x10, 0x08, 0x08, 0x08, 0x08, 0x10, 0x00
  24:test_lcd.c    **** };
  25:test_lcd.c    **** 
  26:test_lcd.c    **** int main(void)
  27:test_lcd.c    **** {
  23               		.loc 1 27 0
  24               		.cfi_startproc
  25 0000 CF93      		push r28
  26               	.LCFI0:
  27               		.cfi_def_cfa_offset 3
  28               		.cfi_offset 28, -2
  29 0002 DF93      		push r29
  30               	.LCFI1:
  31               		.cfi_def_cfa_offset 4
  32               		.cfi_offset 29, -3
  33 0004 CDB7      		in r28,__SP_L__
  34 0006 DEB7      		in r29,__SP_H__
  35               	.LCFI2:
  36               		.cfi_def_cfa_register 28
  37 0008 2797      		sbiw r28,7
  38               	.LCFI3:
  39               		.cfi_def_cfa_offset 11
  40 000a 0FB6      		in __tmp_reg__,__SREG__
  41 000c F894      		cli
  42 000e DEBF      		out __SP_H__,r29
  43 0010 0FBE      		out __SREG__,__tmp_reg__
  44 0012 CDBF      		out __SP_L__,r28
  45               	/* prologue: function */
  46               	/* frame size = 7 */
  47               	/* stack size = 9 */
  48               	.L__stack_usage = 9
  49               	.LVL0:
  28:test_lcd.c    ****     char buffer[7];
  29:test_lcd.c    ****     int  num=134;
  30:test_lcd.c    ****     unsigned char i;
  31:test_lcd.c    ****     
  32:test_lcd.c    ****     /* initialize display, cursor off */
  33:test_lcd.c    ****     lcd_init(LCD_DISP_ON);
  50               		.loc 1 33 0
  51 0014 8CE0      		ldi r24,lo8(12)
  52 0016 0E94 0000 		call lcd_init
  53               	.LVL1:
  54               	.L3:
  34:test_lcd.c    **** 
  35:test_lcd.c    ****     for (;;) {/* loop forever */
  36:test_lcd.c    ****         /* 
  37:test_lcd.c    ****          * Test 1:  write text to display
  38:test_lcd.c    ****          */
  39:test_lcd.c    **** 
  40:test_lcd.c    ****         /* clear display and home cursor */
  41:test_lcd.c    ****         lcd_clrscr();
  55               		.loc 1 41 0
  56 001a 0E94 0000 		call lcd_clrscr
  57               	.LVL2:
  42:test_lcd.c    ****         
  43:test_lcd.c    ****         /* put string to display (line 1) with linefeed */
  44:test_lcd.c    ****         lcd_puts("LCD Test 5\n");
  58               		.loc 1 44 0
  59 001e 80E0      		ldi r24,lo8(.LC0)
  60 0020 90E0      		ldi r25,hi8(.LC0)
  61 0022 0E94 0000 		call lcd_puts
  62               	.LVL3:
  45:test_lcd.c    ****         
  46:test_lcd.c    ****         /* move cursor to position 8 on line 2 */
  47:test_lcd.c    ****         lcd_gotoxy(7,1);  
  63               		.loc 1 47 0
  64 0026 61E0      		ldi r22,lo8(1)
  65 0028 87E0      		ldi r24,lo8(7)
  66 002a 0E94 0000 		call lcd_gotoxy
  67               	.LVL4:
  48:test_lcd.c    ****         
  49:test_lcd.c    ****         /* write single char to display */
  50:test_lcd.c    ****         lcd_putc(':');
  68               		.loc 1 50 0
  69 002e 8AE3      		ldi r24,lo8(58)
  70 0030 0E94 0000 		call lcd_putc
  71               	.LVL5:
  72               	.LBB29:
  73               	.LBB30:
  74               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  75               		.loc 2 187 0
  76 0034 2FEF      		ldi r18,lo8(15999999)
  77 0036 83E2      		ldi r24,hi8(15999999)
  78 0038 94EF      		ldi r25,hlo8(15999999)
  79 003a 2150      	1:	subi r18,1
  80 003c 8040      		sbci r24,0
  81 003e 9040      		sbci r25,0
  82 0040 01F4      		brne 1b
  83 0042 00C0      		rjmp .
  84 0044 0000      		nop
  85               	.LVL6:
  86               	.LBE30:
  87               	.LBE29:
  51:test_lcd.c    ****         
  52:test_lcd.c    ****         _delay_ms(5000);
  53:test_lcd.c    **** 		
  54:test_lcd.c    ****         lcd_clrscr();
  88               		.loc 1 54 0
  89 0046 0E94 0000 		call lcd_clrscr
  90               	.LVL7:
  91               	.LBB31:
  92               	.LBB32:
  93               		.loc 2 187 0
  94 004a EFEF      		ldi r30,lo8(3199999)
  95 004c F3ED      		ldi r31,hi8(3199999)
  96 004e 20E3      		ldi r18,hlo8(3199999)
  97 0050 E150      	1:	subi r30,1
  98 0052 F040      		sbci r31,0
  99 0054 2040      		sbci r18,0
 100 0056 01F4      		brne 1b
 101 0058 00C0      		rjmp .
 102 005a 0000      		nop
 103               	.LVL8:
 104               	.LBE32:
 105               	.LBE31:
  55:test_lcd.c    **** 		_delay_ms(1000);
  56:test_lcd.c    ****         
  57:test_lcd.c    ****         /*
  58:test_lcd.c    ****          * Test 2: use lcd_command() to turn on cursor
  59:test_lcd.c    ****          */
  60:test_lcd.c    ****         
  61:test_lcd.c    ****         /* turn on cursor */
  62:test_lcd.c    ****         lcd_command(LCD_DISP_ON_CURSOR);
 106               		.loc 1 62 0
 107 005c 8EE0      		ldi r24,lo8(14)
 108 005e 0E94 0000 		call lcd_command
 109               	.LVL9:
  63:test_lcd.c    **** 
  64:test_lcd.c    ****         /* put string */
  65:test_lcd.c    ****         lcd_puts("CurOn");
 110               		.loc 1 65 0
 111 0062 80E0      		ldi r24,lo8(.LC1)
 112 0064 90E0      		ldi r25,hi8(.LC1)
 113 0066 0E94 0000 		call lcd_puts
 114               	.LVL10:
 115               	.LBB33:
 116               	.LBB34:
 117               		.loc 2 187 0
 118 006a 8FEF      		ldi r24,lo8(15999999)
 119 006c 93E2      		ldi r25,hi8(15999999)
 120 006e E4EF      		ldi r30,hlo8(15999999)
 121 0070 8150      	1:	subi r24,1
 122 0072 9040      		sbci r25,0
 123 0074 E040      		sbci r30,0
 124 0076 01F4      		brne 1b
 125 0078 00C0      		rjmp .
 126 007a 0000      		nop
 127               	.LVL11:
 128               	.LBE34:
 129               	.LBE33:
  66:test_lcd.c    ****         
  67:test_lcd.c    ****         _delay_ms(5000);
  68:test_lcd.c    **** 
  69:test_lcd.c    ****         /*
  70:test_lcd.c    ****          * Test 3: display shift
  71:test_lcd.c    ****          */
  72:test_lcd.c    ****         
  73:test_lcd.c    ****         lcd_clrscr();     /* clear display home cursor */
 130               		.loc 1 73 0
 131 007c 0E94 0000 		call lcd_clrscr
 132               	.LVL12:
 133               	.LBB35:
 134               	.LBB36:
 135               		.loc 2 187 0
 136 0080 FFEF      		ldi r31,lo8(3199999)
 137 0082 23ED      		ldi r18,hi8(3199999)
 138 0084 80E3      		ldi r24,hlo8(3199999)
 139 0086 F150      	1:	subi r31,1
 140 0088 2040      		sbci r18,0
 141 008a 8040      		sbci r24,0
 142 008c 01F4      		brne 1b
 143 008e 00C0      		rjmp .
 144 0090 0000      		nop
 145               	.LVL13:
 146               	.LBE36:
 147               	.LBE35:
  74:test_lcd.c    **** 		_delay_ms(1000);
  75:test_lcd.c    ****         
  76:test_lcd.c    **** 		//* put string from program memory to display */
  77:test_lcd.c    ****         lcd_puts_P( "Line 1 longer than 14 characters\n" );
 148               		.loc 1 77 0
 149 0092 80E0      		ldi r24,lo8(__c.2071)
 150 0094 90E0      		ldi r25,hi8(__c.2071)
 151 0096 0E94 0000 		call lcd_puts_p
 152               	.LVL14:
  78:test_lcd.c    ****         lcd_puts_P( "Line 2 longer than 14 characters" );
 153               		.loc 1 78 0
 154 009a 80E0      		ldi r24,lo8(__c.2073)
 155 009c 90E0      		ldi r25,hi8(__c.2073)
 156 009e 0E94 0000 		call lcd_puts_p
 157               	.LVL15:
  79:test_lcd.c    ****         
  80:test_lcd.c    ****         /* move BOTH lines one position to the left */
  81:test_lcd.c    ****         lcd_command(LCD_MOVE_DISP_LEFT);
 158               		.loc 1 81 0
 159 00a2 88E1      		ldi r24,lo8(24)
 160 00a4 0E94 0000 		call lcd_command
 161               	.LVL16:
 162               	.LBB37:
 163               	.LBB38:
 164               		.loc 2 187 0
 165 00a8 9FEF      		ldi r25,lo8(15999999)
 166 00aa E3E2      		ldi r30,hi8(15999999)
 167 00ac F4EF      		ldi r31,hlo8(15999999)
 168 00ae 9150      	1:	subi r25,1
 169 00b0 E040      		sbci r30,0
 170 00b2 F040      		sbci r31,0
 171 00b4 01F4      		brne 1b
 172 00b6 00C0      		rjmp .
 173 00b8 0000      		nop
 174               	.LVL17:
 175               	.LBE38:
 176               	.LBE37:
  82:test_lcd.c    ****         
  83:test_lcd.c    ****         _delay_ms(5000);
  84:test_lcd.c    **** 
  85:test_lcd.c    ****         /* turn off cursor */
  86:test_lcd.c    ****         lcd_command(LCD_DISP_ON);
 177               		.loc 1 86 0
 178 00ba 8CE0      		ldi r24,lo8(12)
 179 00bc 0E94 0000 		call lcd_command
 180               	.LVL18:
 181               	.LBB39:
 182               	.LBB40:
 183               		.loc 2 187 0
 184 00c0 2FEF      		ldi r18,lo8(3199999)
 185 00c2 83ED      		ldi r24,hi8(3199999)
 186 00c4 90E3      		ldi r25,hlo8(3199999)
 187 00c6 2150      	1:	subi r18,1
 188 00c8 8040      		sbci r24,0
 189 00ca 9040      		sbci r25,0
 190 00cc 01F4      		brne 1b
 191 00ce 00C0      		rjmp .
 192 00d0 0000      		nop
 193               	.LVL19:
 194               	.LBE40:
 195               	.LBE39:
  87:test_lcd.c    ****         _delay_ms(1000);
  88:test_lcd.c    ****         
  89:test_lcd.c    ****         /*
  90:test_lcd.c    ****          *   Test: Display integer values
  91:test_lcd.c    ****          */
  92:test_lcd.c    ****         
  93:test_lcd.c    **** 		lcd_clrscr();   /* clear display home cursor */
 196               		.loc 1 93 0
 197 00d2 0E94 0000 		call lcd_clrscr
 198               	.LVL20:
 199               	.LBB41:
 200               	.LBB42:
 201               		.loc 2 187 0
 202 00d6 EFEF      		ldi r30,lo8(3199999)
 203 00d8 F3ED      		ldi r31,hi8(3199999)
 204 00da 20E3      		ldi r18,hlo8(3199999)
 205 00dc E150      	1:	subi r30,1
 206 00de F040      		sbci r31,0
 207 00e0 2040      		sbci r18,0
 208 00e2 01F4      		brne 1b
 209 00e4 00C0      		rjmp .
 210 00e6 0000      		nop
 211               	.LVL21:
 212               	.LBE42:
 213               	.LBE41:
 214               	.LBB43:
 215               	.LBB44:
 216               		.file 3 "/usr/lib/avr/include/stdlib.h"
   1:/usr/lib/avr/include/stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:/usr/lib/avr/include/stdlib.h **** 
   4:/usr/lib/avr/include/stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:/usr/lib/avr/include/stdlib.h ****    The Regents of the University of California.
   6:/usr/lib/avr/include/stdlib.h **** 
   7:/usr/lib/avr/include/stdlib.h ****    All rights reserved.
   8:/usr/lib/avr/include/stdlib.h **** 
   9:/usr/lib/avr/include/stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:/usr/lib/avr/include/stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:/usr/lib/avr/include/stdlib.h **** 
  12:/usr/lib/avr/include/stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:/usr/lib/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:/usr/lib/avr/include/stdlib.h **** 
  15:/usr/lib/avr/include/stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:/usr/lib/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:/usr/lib/avr/include/stdlib.h ****      the documentation and/or other materials provided with the
  18:/usr/lib/avr/include/stdlib.h ****      distribution.
  19:/usr/lib/avr/include/stdlib.h **** 
  20:/usr/lib/avr/include/stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:/usr/lib/avr/include/stdlib.h ****      contributors may be used to endorse or promote products derived
  22:/usr/lib/avr/include/stdlib.h ****      from this software without specific prior written permission.
  23:/usr/lib/avr/include/stdlib.h **** 
  24:/usr/lib/avr/include/stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:/usr/lib/avr/include/stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:/usr/lib/avr/include/stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:/usr/lib/avr/include/stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:/usr/lib/avr/include/stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:/usr/lib/avr/include/stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:/usr/lib/avr/include/stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:/usr/lib/avr/include/stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:/usr/lib/avr/include/stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:/usr/lib/avr/include/stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:/usr/lib/avr/include/stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:/usr/lib/avr/include/stdlib.h **** 
  36:/usr/lib/avr/include/stdlib.h ****   $Id$
  37:/usr/lib/avr/include/stdlib.h **** */
  38:/usr/lib/avr/include/stdlib.h **** 
  39:/usr/lib/avr/include/stdlib.h **** #ifndef _STDLIB_H_
  40:/usr/lib/avr/include/stdlib.h **** #define	_STDLIB_H_ 1
  41:/usr/lib/avr/include/stdlib.h **** 
  42:/usr/lib/avr/include/stdlib.h **** #ifndef __ASSEMBLER__
  43:/usr/lib/avr/include/stdlib.h **** 
  44:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  45:/usr/lib/avr/include/stdlib.h **** #define __need_NULL
  46:/usr/lib/avr/include/stdlib.h **** #define __need_size_t
  47:/usr/lib/avr/include/stdlib.h **** #define __need_wchar_t
  48:/usr/lib/avr/include/stdlib.h **** #include <stddef.h>
  49:/usr/lib/avr/include/stdlib.h **** 
  50:/usr/lib/avr/include/stdlib.h **** #ifndef __ptr_t
  51:/usr/lib/avr/include/stdlib.h **** #define __ptr_t void *
  52:/usr/lib/avr/include/stdlib.h **** #endif
  53:/usr/lib/avr/include/stdlib.h **** #endif	/* !__DOXYGEN__ */
  54:/usr/lib/avr/include/stdlib.h **** 
  55:/usr/lib/avr/include/stdlib.h **** #ifdef __cplusplus
  56:/usr/lib/avr/include/stdlib.h **** extern "C" {
  57:/usr/lib/avr/include/stdlib.h **** #endif
  58:/usr/lib/avr/include/stdlib.h **** 
  59:/usr/lib/avr/include/stdlib.h **** /** \file */
  60:/usr/lib/avr/include/stdlib.h **** 
  61:/usr/lib/avr/include/stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  62:/usr/lib/avr/include/stdlib.h ****     \code #include <stdlib.h> \endcode
  63:/usr/lib/avr/include/stdlib.h **** 
  64:/usr/lib/avr/include/stdlib.h ****     This file declares some basic C macros and functions as
  65:/usr/lib/avr/include/stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  66:/usr/lib/avr/include/stdlib.h **** */
  67:/usr/lib/avr/include/stdlib.h **** 
  68:/usr/lib/avr/include/stdlib.h **** /*@{*/
  69:/usr/lib/avr/include/stdlib.h **** /** Result type for function div(). */
  70:/usr/lib/avr/include/stdlib.h **** typedef struct {
  71:/usr/lib/avr/include/stdlib.h **** 	int quot;                   /**< The Quotient. */
  72:/usr/lib/avr/include/stdlib.h **** 	int rem;                    /**< The Remainder. */
  73:/usr/lib/avr/include/stdlib.h **** } div_t;
  74:/usr/lib/avr/include/stdlib.h **** 
  75:/usr/lib/avr/include/stdlib.h **** /** Result type for function ldiv(). */
  76:/usr/lib/avr/include/stdlib.h **** typedef struct {
  77:/usr/lib/avr/include/stdlib.h **** 	long quot;                  /**< The Quotient. */
  78:/usr/lib/avr/include/stdlib.h **** 	long rem;                   /**< The Remainder. */
  79:/usr/lib/avr/include/stdlib.h **** } ldiv_t;
  80:/usr/lib/avr/include/stdlib.h **** 
  81:/usr/lib/avr/include/stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  82:/usr/lib/avr/include/stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  83:/usr/lib/avr/include/stdlib.h **** 
  84:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  85:/usr/lib/avr/include/stdlib.h **** 
  86:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_CONST__
  87:/usr/lib/avr/include/stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  88:/usr/lib/avr/include/stdlib.h **** #endif
  89:/usr/lib/avr/include/stdlib.h **** 
  90:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_MALLOC__
  91:/usr/lib/avr/include/stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  92:/usr/lib/avr/include/stdlib.h **** #endif
  93:/usr/lib/avr/include/stdlib.h **** 
  94:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_NORETURN__
  95:/usr/lib/avr/include/stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  96:/usr/lib/avr/include/stdlib.h **** #endif
  97:/usr/lib/avr/include/stdlib.h **** 
  98:/usr/lib/avr/include/stdlib.h **** #ifndef __ATTR_PURE__
  99:/usr/lib/avr/include/stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
 100:/usr/lib/avr/include/stdlib.h **** #endif
 101:/usr/lib/avr/include/stdlib.h **** 
 102:/usr/lib/avr/include/stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 103:/usr/lib/avr/include/stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 104:/usr/lib/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 105:/usr/lib/avr/include/stdlib.h **** # else
 106:/usr/lib/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__
 107:/usr/lib/avr/include/stdlib.h **** # endif
 108:/usr/lib/avr/include/stdlib.h **** #endif
 109:/usr/lib/avr/include/stdlib.h **** 
 110:/usr/lib/avr/include/stdlib.h **** #endif
 111:/usr/lib/avr/include/stdlib.h **** 
 112:/usr/lib/avr/include/stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 113:/usr/lib/avr/include/stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 114:/usr/lib/avr/include/stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 115:/usr/lib/avr/include/stdlib.h ****     effectively halted by entering an infinite loop. */
 116:/usr/lib/avr/include/stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 117:/usr/lib/avr/include/stdlib.h **** 
 118:/usr/lib/avr/include/stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 119:/usr/lib/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 120:/usr/lib/avr/include/stdlib.h **** */
 121:/usr/lib/avr/include/stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 122:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 123:/usr/lib/avr/include/stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 124:/usr/lib/avr/include/stdlib.h **** #endif
 125:/usr/lib/avr/include/stdlib.h **** 
 126:/usr/lib/avr/include/stdlib.h **** /** The labs() function computes the absolute value of the long integer
 127:/usr/lib/avr/include/stdlib.h ****     \c i.
 128:/usr/lib/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 129:/usr/lib/avr/include/stdlib.h **** */
 130:/usr/lib/avr/include/stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 131:/usr/lib/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 132:/usr/lib/avr/include/stdlib.h **** #define labs(__i) __builtin_labs(__i)
 133:/usr/lib/avr/include/stdlib.h **** #endif
 134:/usr/lib/avr/include/stdlib.h **** 
 135:/usr/lib/avr/include/stdlib.h **** /**
 136:/usr/lib/avr/include/stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 137:/usr/lib/avr/include/stdlib.h ****      initial member of which is pointed to by \c base, for a member
 138:/usr/lib/avr/include/stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 139:/usr/lib/avr/include/stdlib.h ****      member of the array is specified by \c size.
 140:/usr/lib/avr/include/stdlib.h **** 
 141:/usr/lib/avr/include/stdlib.h ****      The contents of the array should be in ascending sorted order
 142:/usr/lib/avr/include/stdlib.h ****      according to the comparison function referenced by \c compar.
 143:/usr/lib/avr/include/stdlib.h ****      The \c compar routine is expected to have two arguments which
 144:/usr/lib/avr/include/stdlib.h ****      point to the key object and to an array member, in that order,
 145:/usr/lib/avr/include/stdlib.h ****      and should return an integer less than, equal to, or greater than
 146:/usr/lib/avr/include/stdlib.h ****      zero if the key object is found, respectively, to be less than,
 147:/usr/lib/avr/include/stdlib.h ****      to match, or be greater than the array member.
 148:/usr/lib/avr/include/stdlib.h **** 
 149:/usr/lib/avr/include/stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 150:/usr/lib/avr/include/stdlib.h ****      the array, or a null pointer if no match is found.  If two
 151:/usr/lib/avr/include/stdlib.h ****      members compare as equal, which member is matched is unspecified.
 152:/usr/lib/avr/include/stdlib.h **** */
 153:/usr/lib/avr/include/stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 154:/usr/lib/avr/include/stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 155:/usr/lib/avr/include/stdlib.h **** 
 156:/usr/lib/avr/include/stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 157:/usr/lib/avr/include/stdlib.h **** /**
 158:/usr/lib/avr/include/stdlib.h ****      The div() function computes the value \c num/denom and returns
 159:/usr/lib/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 160:/usr/lib/avr/include/stdlib.h ****      contains two int members named \c quot and \c rem.
 161:/usr/lib/avr/include/stdlib.h **** */
 162:/usr/lib/avr/include/stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 163:/usr/lib/avr/include/stdlib.h **** /**
 164:/usr/lib/avr/include/stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 165:/usr/lib/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 166:/usr/lib/avr/include/stdlib.h ****      contains two long integer members named \c quot and \c rem.
 167:/usr/lib/avr/include/stdlib.h **** */
 168:/usr/lib/avr/include/stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 169:/usr/lib/avr/include/stdlib.h **** 
 170:/usr/lib/avr/include/stdlib.h **** /**
 171:/usr/lib/avr/include/stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 172:/usr/lib/avr/include/stdlib.h ****      quicksort.
 173:/usr/lib/avr/include/stdlib.h **** 
 174:/usr/lib/avr/include/stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 175:/usr/lib/avr/include/stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 176:/usr/lib/avr/include/stdlib.h ****      each object is specified by \c size.  The contents of the array
 177:/usr/lib/avr/include/stdlib.h ****      base are sorted in ascending order according to a comparison
 178:/usr/lib/avr/include/stdlib.h ****      function pointed to by \c compar, which requires two arguments
 179:/usr/lib/avr/include/stdlib.h ****      pointing to the objects being compared.
 180:/usr/lib/avr/include/stdlib.h **** 
 181:/usr/lib/avr/include/stdlib.h ****      The comparison function must return an integer less than, equal
 182:/usr/lib/avr/include/stdlib.h ****      to, or greater than zero if the first argument is considered to
 183:/usr/lib/avr/include/stdlib.h ****      be respectively less than, equal to, or greater than the second.
 184:/usr/lib/avr/include/stdlib.h **** */
 185:/usr/lib/avr/include/stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 186:/usr/lib/avr/include/stdlib.h **** 		  __compar_fn_t __compar);
 187:/usr/lib/avr/include/stdlib.h **** 
 188:/usr/lib/avr/include/stdlib.h **** /**
 189:/usr/lib/avr/include/stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 190:/usr/lib/avr/include/stdlib.h ****     value.  The conversion is done according to the given base, which
 191:/usr/lib/avr/include/stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 192:/usr/lib/avr/include/stdlib.h **** 
 193:/usr/lib/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 194:/usr/lib/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 195:/usr/lib/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 196:/usr/lib/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 197:/usr/lib/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 198:/usr/lib/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 199:/usr/lib/avr/include/stdlib.h **** 
 200:/usr/lib/avr/include/stdlib.h ****     The remainder of the string is converted to a long value in the
 201:/usr/lib/avr/include/stdlib.h ****     obvious manner, stopping at the first character which is not a
 202:/usr/lib/avr/include/stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 203:/usr/lib/avr/include/stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 204:/usr/lib/avr/include/stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 205:/usr/lib/avr/include/stdlib.h **** 
 206:/usr/lib/avr/include/stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 207:/usr/lib/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 208:/usr/lib/avr/include/stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 209:/usr/lib/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 210:/usr/lib/avr/include/stdlib.h ****     on return, the entire string was valid.)
 211:/usr/lib/avr/include/stdlib.h **** 
 212:/usr/lib/avr/include/stdlib.h ****     The strtol() function returns the result of the conversion, unless
 213:/usr/lib/avr/include/stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 214:/usr/lib/avr/include/stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 215:/usr/lib/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 216:/usr/lib/avr/include/stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 217:/usr/lib/avr/include/stdlib.h **** */
 218:/usr/lib/avr/include/stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 219:/usr/lib/avr/include/stdlib.h **** 
 220:/usr/lib/avr/include/stdlib.h **** /**
 221:/usr/lib/avr/include/stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 222:/usr/lib/avr/include/stdlib.h ****     unsigned long value.  The conversion is done according to the
 223:/usr/lib/avr/include/stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 224:/usr/lib/avr/include/stdlib.h ****     special value 0.
 225:/usr/lib/avr/include/stdlib.h **** 
 226:/usr/lib/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 227:/usr/lib/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 228:/usr/lib/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 229:/usr/lib/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 230:/usr/lib/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 231:/usr/lib/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 232:/usr/lib/avr/include/stdlib.h **** 
 233:/usr/lib/avr/include/stdlib.h ****     The remainder of the string is converted to an unsigned long value
 234:/usr/lib/avr/include/stdlib.h ****     in the obvious manner, stopping at the first character which is
 235:/usr/lib/avr/include/stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 236:/usr/lib/avr/include/stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 237:/usr/lib/avr/include/stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 238:/usr/lib/avr/include/stdlib.h **** 
 239:/usr/lib/avr/include/stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 240:/usr/lib/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 241:/usr/lib/avr/include/stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 242:/usr/lib/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 243:/usr/lib/avr/include/stdlib.h ****     on return, the entire string was valid.)
 244:/usr/lib/avr/include/stdlib.h **** 
 245:/usr/lib/avr/include/stdlib.h ****     The strtoul() function return either the result of the conversion
 246:/usr/lib/avr/include/stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 247:/usr/lib/avr/include/stdlib.h ****     of the conversion, unless the original (non-negated) value would
 248:/usr/lib/avr/include/stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 249:/usr/lib/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 250:/usr/lib/avr/include/stdlib.h ****     be performed, 0 is returned.
 251:/usr/lib/avr/include/stdlib.h **** */
 252:/usr/lib/avr/include/stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 253:/usr/lib/avr/include/stdlib.h **** 
 254:/usr/lib/avr/include/stdlib.h **** /**
 255:/usr/lib/avr/include/stdlib.h ****     The atol() function converts the initial portion of the string
 256:/usr/lib/avr/include/stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 257:/usr/lib/avr/include/stdlib.h **** 
 258:/usr/lib/avr/include/stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 259:/usr/lib/avr/include/stdlib.h **** 
 260:/usr/lib/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 261:/usr/lib/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 262:/usr/lib/avr/include/stdlib.h ****     stack) and works more quickly.
 263:/usr/lib/avr/include/stdlib.h **** */
 264:/usr/lib/avr/include/stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 265:/usr/lib/avr/include/stdlib.h **** 
 266:/usr/lib/avr/include/stdlib.h **** /**
 267:/usr/lib/avr/include/stdlib.h ****     The atoi() function converts the initial portion of the string
 268:/usr/lib/avr/include/stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 269:/usr/lib/avr/include/stdlib.h **** 
 270:/usr/lib/avr/include/stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 271:/usr/lib/avr/include/stdlib.h **** 
 272:/usr/lib/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 273:/usr/lib/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 274:/usr/lib/avr/include/stdlib.h ****     stack) and works more quickly.
 275:/usr/lib/avr/include/stdlib.h **** */
 276:/usr/lib/avr/include/stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 277:/usr/lib/avr/include/stdlib.h **** 
 278:/usr/lib/avr/include/stdlib.h **** /**
 279:/usr/lib/avr/include/stdlib.h ****    The exit() function terminates the application.  Since there is no
 280:/usr/lib/avr/include/stdlib.h ****    environment to return to, \c status is ignored, and code execution
 281:/usr/lib/avr/include/stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 282:/usr/lib/avr/include/stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 283:/usr/lib/avr/include/stdlib.h ****    are globally disabled.
 284:/usr/lib/avr/include/stdlib.h **** 
 285:/usr/lib/avr/include/stdlib.h ****    In a C++ context, global destructors will be called before halting
 286:/usr/lib/avr/include/stdlib.h ****    execution.
 287:/usr/lib/avr/include/stdlib.h **** */
 288:/usr/lib/avr/include/stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 289:/usr/lib/avr/include/stdlib.h **** 
 290:/usr/lib/avr/include/stdlib.h **** /**
 291:/usr/lib/avr/include/stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 292:/usr/lib/avr/include/stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 293:/usr/lib/avr/include/stdlib.h **** 
 294:/usr/lib/avr/include/stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 295:/usr/lib/avr/include/stdlib.h ****    zero bytes.
 296:/usr/lib/avr/include/stdlib.h **** 
 297:/usr/lib/avr/include/stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 298:/usr/lib/avr/include/stdlib.h ****    details.
 299:/usr/lib/avr/include/stdlib.h **** */
 300:/usr/lib/avr/include/stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 301:/usr/lib/avr/include/stdlib.h **** 
 302:/usr/lib/avr/include/stdlib.h **** /**
 303:/usr/lib/avr/include/stdlib.h ****    The free() function causes the allocated memory referenced by \c
 304:/usr/lib/avr/include/stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 305:/usr/lib/avr/include/stdlib.h ****    NULL, no action occurs.
 306:/usr/lib/avr/include/stdlib.h **** */
 307:/usr/lib/avr/include/stdlib.h **** extern void free(void *__ptr);
 308:/usr/lib/avr/include/stdlib.h **** 
 309:/usr/lib/avr/include/stdlib.h **** /**
 310:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 311:/usr/lib/avr/include/stdlib.h **** */
 312:/usr/lib/avr/include/stdlib.h **** extern size_t __malloc_margin;
 313:/usr/lib/avr/include/stdlib.h **** 
 314:/usr/lib/avr/include/stdlib.h **** /**
 315:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 316:/usr/lib/avr/include/stdlib.h **** */
 317:/usr/lib/avr/include/stdlib.h **** extern char *__malloc_heap_start;
 318:/usr/lib/avr/include/stdlib.h **** 
 319:/usr/lib/avr/include/stdlib.h **** /**
 320:/usr/lib/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 321:/usr/lib/avr/include/stdlib.h **** */
 322:/usr/lib/avr/include/stdlib.h **** extern char *__malloc_heap_end;
 323:/usr/lib/avr/include/stdlib.h **** 
 324:/usr/lib/avr/include/stdlib.h **** /**
 325:/usr/lib/avr/include/stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 326:/usr/lib/avr/include/stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 327:/usr/lib/avr/include/stdlib.h ****    allocated memory will be cleared to zero.
 328:/usr/lib/avr/include/stdlib.h **** */
 329:/usr/lib/avr/include/stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 330:/usr/lib/avr/include/stdlib.h **** 
 331:/usr/lib/avr/include/stdlib.h **** /**
 332:/usr/lib/avr/include/stdlib.h ****    The realloc() function tries to change the size of the region
 333:/usr/lib/avr/include/stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 334:/usr/lib/avr/include/stdlib.h ****    pointer to the new region.  The returned pointer might be the
 335:/usr/lib/avr/include/stdlib.h ****    same as the old pointer, or a pointer to a completely different
 336:/usr/lib/avr/include/stdlib.h ****    region.
 337:/usr/lib/avr/include/stdlib.h **** 
 338:/usr/lib/avr/include/stdlib.h ****    The contents of the returned region up to either the old or the new
 339:/usr/lib/avr/include/stdlib.h ****    size value (whatever is less) will be identical to the contents of
 340:/usr/lib/avr/include/stdlib.h ****    the old region, even in case a new region had to be allocated.
 341:/usr/lib/avr/include/stdlib.h **** 
 342:/usr/lib/avr/include/stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 343:/usr/lib/avr/include/stdlib.h ****    will behave identical to malloc().
 344:/usr/lib/avr/include/stdlib.h **** 
 345:/usr/lib/avr/include/stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 346:/usr/lib/avr/include/stdlib.h ****    the region at \c ptr will not be changed.
 347:/usr/lib/avr/include/stdlib.h **** */
 348:/usr/lib/avr/include/stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 349:/usr/lib/avr/include/stdlib.h **** 
 350:/usr/lib/avr/include/stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 351:/usr/lib/avr/include/stdlib.h **** 
 352:/usr/lib/avr/include/stdlib.h **** /** \ingroup avr_stdlib
 353:/usr/lib/avr/include/stdlib.h ****     \fn  double atof (const char *nptr)
 354:/usr/lib/avr/include/stdlib.h **** 
 355:/usr/lib/avr/include/stdlib.h ****     The atof() function converts the initial portion of the string pointed
 356:/usr/lib/avr/include/stdlib.h ****     to by \a nptr to double representation.
 357:/usr/lib/avr/include/stdlib.h **** 
 358:/usr/lib/avr/include/stdlib.h ****     It is equivalent to calling
 359:/usr/lib/avr/include/stdlib.h **** 	\code strtod(nptr, (char **)0); \endcode
 360:/usr/lib/avr/include/stdlib.h ****  */
 361:/usr/lib/avr/include/stdlib.h **** extern double atof(const char *__nptr);
 362:/usr/lib/avr/include/stdlib.h **** 
 363:/usr/lib/avr/include/stdlib.h **** /** Highest number that can be generated by rand(). */
 364:/usr/lib/avr/include/stdlib.h **** #define	RAND_MAX 0x7FFF
 365:/usr/lib/avr/include/stdlib.h **** 
 366:/usr/lib/avr/include/stdlib.h **** /**
 367:/usr/lib/avr/include/stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 368:/usr/lib/avr/include/stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 369:/usr/lib/avr/include/stdlib.h **** 
 370:/usr/lib/avr/include/stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 371:/usr/lib/avr/include/stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 372:/usr/lib/avr/include/stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 373:/usr/lib/avr/include/stdlib.h **** 
 374:/usr/lib/avr/include/stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 375:/usr/lib/avr/include/stdlib.h ****      a value of 1.
 376:/usr/lib/avr/include/stdlib.h **** 
 377:/usr/lib/avr/include/stdlib.h ****      In compliance with the C standard, these functions operate on
 378:/usr/lib/avr/include/stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 379:/usr/lib/avr/include/stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 380:/usr/lib/avr/include/stdlib.h ****      \c random() for an alternate set of functions that retains full
 381:/usr/lib/avr/include/stdlib.h ****      32-bit precision.
 382:/usr/lib/avr/include/stdlib.h **** */
 383:/usr/lib/avr/include/stdlib.h **** extern int rand(void);
 384:/usr/lib/avr/include/stdlib.h **** /**
 385:/usr/lib/avr/include/stdlib.h ****    Pseudo-random number generator seeding; see rand().
 386:/usr/lib/avr/include/stdlib.h **** */
 387:/usr/lib/avr/include/stdlib.h **** extern void srand(unsigned int __seed);
 388:/usr/lib/avr/include/stdlib.h **** 
 389:/usr/lib/avr/include/stdlib.h **** /**
 390:/usr/lib/avr/include/stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 391:/usr/lib/avr/include/stdlib.h ****    variable located at \c ctx instead of a static library variable
 392:/usr/lib/avr/include/stdlib.h ****    so the function becomes re-entrant.
 393:/usr/lib/avr/include/stdlib.h **** */
 394:/usr/lib/avr/include/stdlib.h **** extern int rand_r(unsigned long *__ctx);
 395:/usr/lib/avr/include/stdlib.h **** /*@}*/
 396:/usr/lib/avr/include/stdlib.h **** 
 397:/usr/lib/avr/include/stdlib.h **** /*@{*/
 398:/usr/lib/avr/include/stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 399:/usr/lib/avr/include/stdlib.h ****  \ingroup avr_stdlib
 400:/usr/lib/avr/include/stdlib.h **** */
 401:/usr/lib/avr/include/stdlib.h **** /**
 402:/usr/lib/avr/include/stdlib.h ****    \brief Convert an integer to a string.
 403:/usr/lib/avr/include/stdlib.h **** 
 404:/usr/lib/avr/include/stdlib.h ****    The function itoa() converts the integer value from \c val into an
 405:/usr/lib/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 406:/usr/lib/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 407:/usr/lib/avr/include/stdlib.h **** 
 408:/usr/lib/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 409:/usr/lib/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 410:/usr/lib/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 411:/usr/lib/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 412:/usr/lib/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 413:/usr/lib/avr/include/stdlib.h **** 
 414:/usr/lib/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 415:/usr/lib/avr/include/stdlib.h **** 
 416:/usr/lib/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 417:/usr/lib/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 418:/usr/lib/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 419:/usr/lib/avr/include/stdlib.h ****    \c 'a'.
 420:/usr/lib/avr/include/stdlib.h ****     
 421:/usr/lib/avr/include/stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 422:/usr/lib/avr/include/stdlib.h **** 
 423:/usr/lib/avr/include/stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 424:/usr/lib/avr/include/stdlib.h **** */
 425:/usr/lib/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 426:/usr/lib/avr/include/stdlib.h **** extern char *itoa(int val, char *s, int radix);
 427:/usr/lib/avr/include/stdlib.h **** #else
 428:/usr/lib/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 429:/usr/lib/avr/include/stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 430:/usr/lib/avr/include/stdlib.h **** {
 431:/usr/lib/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 432:/usr/lib/avr/include/stdlib.h **** 	extern char *__itoa (int, char *, int);
 433:/usr/lib/avr/include/stdlib.h **** 	return __itoa (__val, __s, __radix);
 434:/usr/lib/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 435:/usr/lib/avr/include/stdlib.h **** 	*__s = 0;
 436:/usr/lib/avr/include/stdlib.h **** 	return __s;
 437:/usr/lib/avr/include/stdlib.h ****     } else {
 438:/usr/lib/avr/include/stdlib.h **** 	extern char *__itoa_ncheck (int, char *, unsigned char);
 439:/usr/lib/avr/include/stdlib.h **** 	return __itoa_ncheck (__val, __s, __radix);
 217               		.loc 3 439 0
 218 00e8 4AE0      		ldi r20,lo8(10)
 219 00ea BE01      		movw r22,r28
 220 00ec 6F5F      		subi r22,-1
 221 00ee 7F4F      		sbci r23,-1
 222 00f0 86E8      		ldi r24,lo8(-122)
 223 00f2 90E0      		ldi r25,0
 224 00f4 0E94 0000 		call __itoa_ncheck
 225               	.LVL22:
 226               	.LBE44:
 227               	.LBE43:
  94:test_lcd.c    ****         _delay_ms(1000);
  95:test_lcd.c    ****         
  96:test_lcd.c    **** 		/* convert interger into string */
  97:test_lcd.c    **** 		itoa( num , buffer, 10);
  98:test_lcd.c    ****         
  99:test_lcd.c    ****         /* put converted string to display */
 100:test_lcd.c    ****         lcd_puts(buffer);
 228               		.loc 1 100 0
 229 00f8 CE01      		movw r24,r28
 230 00fa 0196      		adiw r24,1
 231 00fc 0E94 0000 		call lcd_puts
 232               	.LVL23:
 233               	.LBB45:
 234               	.LBB46:
 235               		.loc 2 187 0
 236 0100 8FEF      		ldi r24,lo8(15999999)
 237 0102 93E2      		ldi r25,hi8(15999999)
 238 0104 E4EF      		ldi r30,hlo8(15999999)
 239 0106 8150      	1:	subi r24,1
 240 0108 9040      		sbci r25,0
 241 010a E040      		sbci r30,0
 242 010c 01F4      		brne 1b
 243 010e 00C0      		rjmp .
 244 0110 0000      		nop
 245               	.LVL24:
 246               	.LBE46:
 247               	.LBE45:
 101:test_lcd.c    ****         
 102:test_lcd.c    ****         _delay_ms(5000);
 103:test_lcd.c    ****         
 104:test_lcd.c    ****         
 105:test_lcd.c    ****         /*
 106:test_lcd.c    ****          *  Test: Display userdefined characters
 107:test_lcd.c    ****          */
 108:test_lcd.c    **** 
 109:test_lcd.c    ****         lcd_clrscr();   /* clear display home cursor */
 248               		.loc 1 109 0
 249 0112 0E94 0000 		call lcd_clrscr
 250               	.LVL25:
 251               	.LBB47:
 252               	.LBB48:
 253               		.loc 2 187 0
 254 0116 FFEF      		ldi r31,lo8(3199999)
 255 0118 23ED      		ldi r18,hi8(3199999)
 256 011a 80E3      		ldi r24,hlo8(3199999)
 257 011c F150      	1:	subi r31,1
 258 011e 2040      		sbci r18,0
 259 0120 8040      		sbci r24,0
 260 0122 01F4      		brne 1b
 261 0124 00C0      		rjmp .
 262 0126 0000      		nop
 263               	.LVL26:
 264               	.LBE48:
 265               	.LBE47:
 110:test_lcd.c    ****         _delay_ms(1000);
 111:test_lcd.c    ****         lcd_puts("Copyright: ");
 266               		.loc 1 111 0
 267 0128 80E0      		ldi r24,lo8(.LC2)
 268 012a 90E0      		ldi r25,hi8(.LC2)
 269 012c 0E94 0000 		call lcd_puts
 270               	.LVL27:
 112:test_lcd.c    ****        
 113:test_lcd.c    ****        /*
 114:test_lcd.c    ****         * load two userdefined characters from program memory
 115:test_lcd.c    ****         * into LCD controller CG RAM location 0 and 1
 116:test_lcd.c    ****         */
 117:test_lcd.c    ****         lcd_command(_BV(LCD_CGRAM));  /* set CG RAM start address 0 */
 271               		.loc 1 117 0
 272 0130 80E4      		ldi r24,lo8(64)
 273 0132 0E94 0000 		call lcd_command
 274               	.LVL28:
 275 0136 00E0      		ldi r16,lo8(copyRightChar)
 276 0138 10E0      		ldi r17,hi8(copyRightChar)
 277               	.LVL29:
 278               	.L2:
 279               	.LBB49:
 118:test_lcd.c    ****         for(i=0; i<16; i++){
 119:test_lcd.c    ****            lcd_data(pgm_read_byte_near(&copyRightChar[i]));
 280               		.loc 1 119 0 discriminator 3
 281 013a F801      		movw r30,r16
 282               	/* #APP */
 283               	 ;  119 "test_lcd.c" 1
 284 013c 8491      		lpm r24, Z
 285               		
 286               	 ;  0 "" 2
 287               	.LVL30:
 288               	/* #NOAPP */
 289               	.LBE49:
 290               		.loc 1 119 0 discriminator 3
 291 013e 0E94 0000 		call lcd_data
 292               	.LVL31:
 293 0142 0F5F      		subi r16,-1
 294 0144 1F4F      		sbci r17,-1
 295               	.LVL32:
 118:test_lcd.c    ****         for(i=0; i<16; i++){
 296               		.loc 1 118 0 discriminator 3
 297 0146 F0E0      		ldi r31,hi8(copyRightChar+16)
 298 0148 0030      		cpi r16,lo8(copyRightChar+16)
 299 014a 1F07      		cpc r17,r31
 300 014c 01F4      		brne .L2
 120:test_lcd.c    ****         }
 121:test_lcd.c    ****        
 122:test_lcd.c    ****        /* move cursor to position 0 on line 2 */
 123:test_lcd.c    ****        /* Note: this switched back to DD RAM adresses */
 124:test_lcd.c    ****        lcd_gotoxy(0,1);
 301               		.loc 1 124 0
 302 014e 61E0      		ldi r22,lo8(1)
 303 0150 80E0      		ldi r24,0
 304 0152 0E94 0000 		call lcd_gotoxy
 305               	.LVL33:
 125:test_lcd.c    ****        
 126:test_lcd.c    ****        /* display user defined (c), built using two user defined chars */
 127:test_lcd.c    ****        lcd_putc(0);
 306               		.loc 1 127 0
 307 0156 80E0      		ldi r24,0
 308 0158 0E94 0000 		call lcd_putc
 309               	.LVL34:
 128:test_lcd.c    ****        lcd_putc(1);
 310               		.loc 1 128 0
 311 015c 81E0      		ldi r24,lo8(1)
 312 015e 0E94 0000 		call lcd_putc
 313               	.LVL35:
 314               	.LBB50:
 315               	.LBB51:
 316               		.loc 2 187 0
 317 0162 2FEF      		ldi r18,lo8(15999999)
 318 0164 83E2      		ldi r24,hi8(15999999)
 319 0166 94EF      		ldi r25,hlo8(15999999)
 320 0168 2150      	1:	subi r18,1
 321 016a 8040      		sbci r24,0
 322 016c 9040      		sbci r25,0
 323 016e 01F4      		brne 1b
 324 0170 00C0      		rjmp .
 325 0172 0000      		nop
 326 0174 00C0      		rjmp .L3
 327               	.LBE51:
 328               	.LBE50:
 329               		.cfi_endproc
 330               	.LFE11:
 332               		.section	.progmem.data,"a",@progbits
 335               	__c.2073:
 336 0000 4C69 6E65 		.string	"Line 2 longer than 14 characters"
 336      2032 206C 
 336      6F6E 6765 
 336      7220 7468 
 336      616E 2031 
 339               	__c.2071:
 340 0021 4C69 6E65 		.string	"Line 1 longer than 14 characters\n"
 340      2031 206C 
 340      6F6E 6765 
 340      7220 7468 
 340      616E 2031 
 343               	copyRightChar:
 344 0043 07        		.byte	7
 345 0044 08        		.byte	8
 346 0045 13        		.byte	19
 347 0046 14        		.byte	20
 348 0047 14        		.byte	20
 349 0048 13        		.byte	19
 350 0049 08        		.byte	8
 351 004a 07        		.byte	7
 352 004b 00        		.byte	0
 353 004c 10        		.byte	16
 354 004d 08        		.byte	8
 355 004e 08        		.byte	8
 356 004f 08        		.byte	8
 357 0050 08        		.byte	8
 358 0051 10        		.byte	16
 359 0052 00        		.byte	0
 360               		.text
 361               	.Letext0:
 362               		.file 4 "/usr/lib/avr/include/stdint.h"
 363               		.file 5 "lcd.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 test_lcd.c
          test_lcd.s:2      *ABS*:000000000000003e __SP_H__
          test_lcd.s:3      *ABS*:000000000000003d __SP_L__
          test_lcd.s:4      *ABS*:000000000000003f __SREG__
          test_lcd.s:5      *ABS*:0000000000000000 __tmp_reg__
          test_lcd.s:6      *ABS*:0000000000000001 __zero_reg__
          test_lcd.s:20     .text.startup:0000000000000000 main
          test_lcd.s:339    .progmem.data:0000000000000021 __c.2071
          test_lcd.s:335    .progmem.data:0000000000000000 __c.2073
          test_lcd.s:343    .progmem.data:0000000000000043 copyRightChar

UNDEFINED SYMBOLS
lcd_init
lcd_clrscr
lcd_puts
lcd_gotoxy
lcd_putc
lcd_command
lcd_puts_p
__itoa_ncheck
lcd_data
__do_copy_data
